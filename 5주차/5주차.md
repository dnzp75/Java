### concurrentMap같은 concurrent가 붙어있는 자료구조와 HashTable같이 synchronized가 붙은 자료구조들의 차이(복습)
<details>
<summary>생각해보고 답 확인</summary>

ConcurrentHashMap은 Hashtable처럼 모든 요청에 대한 동시성 처리에 있어 전체 Map에 대하여 Lock을 거는 것이 아니라, 꼭 필요한 부분에서만 Table Bucket에 대한 Lock을 사용하여 성능을 높인 방식인데요.

빈 bucket에 대한 최초 node 삽입 시에도 lock이 아닌 compare and swap 방식이 사용되며, 그 외에 업데이트*(삽입, 삭제, 교체 작업)*에서는 해당 버킷에 대해 synchronized 키워드를 통한 block/unblock이 적용되게 됩니다.

**Hashtable**의 경우 synchronized 키워드로 인해 Map 전체에 block/unblock 처리가 적용되어 thread-safe 하지만 성능적인 오버헤드를 발생 → 병목현상이 발생

**ConcurrentHashMap**의 경우 Map의 일부분에만 block/unblock 처리가 적용되기 때문에 thread-safe라는 특징을 가져가면서도 성능까지 고려된 클래스입니다.

내부적으로 관리하는 **가변 배열 table**

꼭 필요한 부분에서만 Table Bucket에 대한 Lock을 사용하여 성능을 높인 방식인데요.

빈 bucket에 대한 최초 node 삽입 시에도 lock이 아닌 compare and swap 방식이 사용되며, 그 외에 업데이트*(삽입, 삭제, 교체 작업)*에서는 해당 버킷에 대해 synchronized 키워드를 통한 block/unblock이 적용되게 됩니다.

### **HashTable**

동일한 인스턴스에 대해 동시에 여러 요청이 들어오게 되는 경우, 

메소드 호출 전 쓰레드간 동기화 락을 통해 멀티 쓰레드 환경에서 data의 무결성을 보장해준다.

※ **Map 전체에 block/unblock 처리 적용 과정** 

- **빈 해시 버킷에 node를 삽입하는 경우 /** 버킷에 이미 Node가 존재하는 경우 ****

      block/unblock 과정을 통해 **Lock을 걸어서 동시성 문제를 처리**

### **ConcurrentHashMap 동기화 동작 원리**

### **get() method**

ConcurrentHashMap의 get() 메서드 synchronized 키워드가 존재 X

따라서 get() 메서드를 포함한 검색 작업 요청 시에는 스레드 동기화가 적용되지 않으며 put(), remove() 등의 업데이트 작업과 동시에 수행될 수 있습니다.

때문에 get() 메서드 등의 검색 작업은 요청이 들어왔을 때, **'가장 최근에 완료된 업데이트의 작업 결과를 반영'**

### **put() method**

put(key, value) 메서드 호출 시 내부적으로 putVal(key, value, onlyIfAbsent) 메서드가 실행되는데요.

putVal() 메서드를 살펴보면 메서드 자체에 synchronized 키워드가 적용된 것이 아니라, 메서드 동작 과정에서 synchronized 키워드가 사용되는 것

*(코드를 살펴보면 해당 버킷에 대한 노드가 이미 존재할 때 분기처리 되는 부분에서만 synchronized가 적용되는 것을 확인할 수 있습니다.)*

즉, ConcurrentHashMap의 업데이트 작업*(put 외에 remove, clear 메서드 등을 포함)*에서는 **각각의 Table Bucket 별로 block/unblock 처리가 진행되기 때문에 멀티스레드 환경에서의 성능이 향상되는 것**

### 코드 안에서의 동작 원리

위 코드에서 1번 부분은 ConcurrentHashMap 내부적으로 관리하는 **가변 배열 table**을 무한 루프로 돌리는 과정인데요.

이 과정을 통해 데이터가 삽입될 bucket을 확인 / tabAt() 메서드를 통해 해당 bucket을 가져오고

- **putVal() 메서드 동작 시 Bucket에 Node가 존재하는 경우**

     synchronized 키워드를 이용해 하나의 thread만 해당 bucket에 접근할 수 있도록 제어

     서로 다른 thread가 같은 Hash Bucket에 접근할 때만 block이 걸리게 됩니다.

- **해당 bucket이 null로 비어있는 경우**

    casTabAt() 메서드를 통해 new Node를 해당 bucket에 삽입하는 과정 으로 Compare and Swap 방식이 적용

    Compare and Swap*(cas)*는 멀티스레드 환경에서 Atomic 연산으로 동시성 문제 처리를 위한 Non-Blocking 방식

CAS 알고리즘은 현재 스레드가 가지고 있는 기존값과 메모리가 가지고 있는 값을 비교해 같은 경우 변경할 값을 메모리에 반영하고 true를 반환한다. 다른 경우에는 변경값이 반영되지 않고 false를 반환한 다음 재시도를 하는 방식으로 동작한다. CAS 알고리즘을 통해 가시성과 원자성 문제를 해결할 수 있다.

</details>

------
### stream과 buffer는 어떤것이고 어떤 차이가 있는지(지난주에 못한것)
<details>
<summary>생각해보고 답 확인</summary>

- **Byte 형태로** **데이터를 운반하는데 사용되는 연결통로**
- **단방향 통신만 가능**

       → 하나의 스트림으로 입력과 출력을 동시에 처리 할 수 없다.  

- **큐(queue)의 FIFO(First in Frist Out) 구조**로 되어 있다.

**Source - 입력 스트림 input Stream- 출력 스트림 output Stream- Sink** 순서로 데이터가 흐른다.

따라서 **입력과 출력을 통시에 수행하려면** 

입력을 위한 **입력 스트림(input stream)과 출력을 위한(output stream), 모두 2개의 스트림이 필요**하다는 것

**Buffer란, 임시로 데이터를 담아둘 수있는 일종의 큐이다.** 

Buffer 는 가변적인 값을 받을 수 있으며, 입력받은 값을 Buffer 에 저장하고, Buffer 에 저장한 값을 한번에 출력하기 때문에 보다 **빠른 속도를 자랑**한다!

바이트 단위의 데이터가 입력될 때마다 Stream은 즉시 전송하게 되는데 이것은 디스크 접근이나 네트워크 접근같은 오버헤드가 발생하기 때문에 매우 비효율적인 방법이다. Buffer는 중간에서 입력을 모아서 한번에 출력함으로써 I/O 의 성능을 향상시키는 역할을 한다.

</details>   

------
### TCP와 UDP의 차이
<details>
<summary>생각해보고 답 확인</summary>

**TCP는 연속성보다 신뢰성 있는 전송이 중요할 때에 사용되는 프로토콜이며,**

**UDP는 TCP보다 빠르고 네트워크 부하가 적다는 장점이 있지만 신뢰성 있는 데이터 전송을 보장하지는 않습니다.그렇기 때문에 신뢰성보다는 연속성이 중요한 실시간 스트리밍과 같은 서비스에 자주 사용됩니다.**

| 프로토콜 종류 | TCP | UDP |
| --- | --- | --- |
| 연결 방식connected or not | 연결형 서비스 | 비연결형 서비스 |
| 패킷 교환 방식packet | 가상 회선 방식 | 데이터그램 방식 |
| 전송 순서in order or not | 전송 순서 보장 O | 전송 순서 보장 X |
| 흐름 제어Flow control | 제어함 O | 제어 안함 X |
| 혼잡 제어Congestion control | 제어함 O | 제어 안함 X |
| 수신 여부 확인receiver check | 수신 여부 확인 O | 수신 여부 확인 X |
| 통신 방식commucation | 1 : 1 통신 | 1 : 1,   1 : N,  N : N   모두 가능 |
| 신뢰성reliable or not | 좋음 | 좋지 않음 |
| 속도speed | 느림 | 빠름 |
| 기능 및 자원 소모 | 기능 많다-> 자원 소모 많음 | 기능 적다-> 자원 소모 적음 |
| 사용되는 예시examples in reality | 파인 전송, 영화 다운, 웹 브라우저 사용, email | 실시간 스트리밍, 음성전화(보이스 콜), 보이스 메세지, FAX, SMS |
| 결론 | 중요한 정보, 신뢰성이 필요한 전송 시 TCP를 사용! | 조금 유실되도 괜찮다 싶고 연속성이 더 중요하다면 UDP를 사용 ! |

</details>   

-----
### TCP는 어떻게 연결을 맺고 끊는지
<details>
<summary>생각해보고 답 확인</summary>

### TCP의 3way-handShake, 4way-handShake

TCP에서 상대와 연결하기 위해 3번의 데이터를 주고받는데 이를 3way-handShake라 한다. 상대방과의 연결을 끊기위해서 4번의 데이터를 주고받는데 이를 4way-handShake라 한다.

**3way-handShake 과정**

<p align="center">
<img src="https://github.com/Cee/Leetcode/assets/105201451/1487bffe-219a-4878-b8a2-828446352c0e" width="400" height="300"/>
   
1. client는 처음에 SYN요청을 보낸다. 이는 Server와 연결하고싶다는 요청을 보낸것이다. 
2. Server는 해당 요청을 받으면 SYN요청의 SEQ+1을 ACK로 하여 응답을 보낸다.이는 요청을 잘 받았고, Server에서도 client에게 연결해달라는 요청이다. 
3. 해당 요청을 받은 Client는 요청을 잘 받았고 연결도 완료했다는 의미로 한번더 패킷을 보낸다. 해당 과정을 거치면 연결이 완료된다.

### 왜 3단계에 걸쳐서 통신을 하는가?

그리고 TCP는 장치들 사이에 논리적인 접속을 성립(establish)하기 위해서 3-way handshake를 사용한다.

### 두 장군 문제에 대해 들어보았는가?

**4way-handShake 과정**

<p align="center">
<img src="https://github.com/Cee/Leetcode/assets/105201451/e45ee8ba-4bb4-4a4b-aa84-4191fd0c2814" width="400" height="300"/>

client가 close메서드를 호출하면 FIN메시지가 Server에게 전달된다. 이는 연결을 끊고자 하는 요청이다. 

해당 요청을받은 Server는 ACK메시지를 보낸다. 이는 요청을 잘 받았고 잠시 기다리라는 의미이다. 

이후 server는 close메서드를 호출하고 client에게 FIN메시지가 전달된다. 

해당 메시지를 받은 Client는 ACK요청을 통해 메시지를 잘 전달받았음을 알리고 socket을 닫는다. server또한 ACK요청을 받으면 socket을 닫고 연결이 끊긴다.

</details>  

------
### https는 어떻게 작동하고 대칭키/비대칭키란 어떤건지
<details>
<summary>생각해보고 답 확인</summary>

**HTTPS**

웹에서 정보를 보호하기 위한 가장 기본적인 기술

HTTPS가 어떤 보안 기술로 브라우저와 웹 서버 사이의 통신을 지킬 수 있는지 

# **HTTPS는 무엇인가?**

<p align="center">
<img src="https://github.com/Cee/Leetcode/assets/105201451/50e1cb7a-ab10-45e8-b558-949e3a608852" width="300" height="200"/>
   
HTTPS를 통한 암호화 통신 

웹은 안전한 통신을 위해 정보를 암호화합니다. 

**암호화**란 일반적인 평문을 알아볼 수 없도록 암호화하여 암호문으로 만드는 과정입니다. 

개인 정보가 담긴 평문을 **암호화**하고, 이렇게 만들어진 **암호문을 상대방에게 전달**하면, 상대방은 이를 다시 **복호화** 하여 원래의 **평문으로 열람**할 수 있습니다.

이와 같은 과정을 웹 브라우저와 웹 서버에 사용하는 대표적인 기술이 바로 HTTPS(Hypertext Transfer Protocol Secure)입니다. 인터넷 콘텐츠를 전달하는 TCP 프로토콜의 일종인 HTTP에 S(Secure) 기능을 더한 것

HTTPS의 원천 기술로는 **SSL(Secure Socket Layer)**과 **TLS(Transport Layer Security) 전송 기술**이 있습니다. 

단어에서 알 수 있듯이 안전한 계층(layer)을 웹 통신에 추가하는 방식

. 이 기술을 수행하기 위해 웹 서버에 설치하는 것이 **SSL/TLS 인증서**

# **SSL 인증서와 SSL 핸드셰이크에 탑재된 기술**

SSL 인증서 관련 프로세스에는 아래와 같은 보안 기술이 탑재되어 있습니다.

- 대칭키 암호화 방식
- 비대칭키 암호화 방식
- 통신 대상을 서로가 확인하는 신분 확인
- 믿을 수 있는 SSL 인증서를 위한 디지털 서명
- 디지털 서명을 해주는 인증 기관의 확인
- 공개키를 안전하게 전달하고 공유하기 위한 프로토콜
- 암호화된 메시지의 변조 여부를 확인하는 메시지 무결성 알고리즘

SSL에 사용된 보안 기술은 암호화, 인증, 서명, 공개키, 무결성 확인 등 매우 다양하기에 이것만 잘 이해하고 있어도, 웬만한 IT 보안 기술에 대한 기본은 이해할 수 있습니다. 이 중에서 대표적인 암호화 방식 두 개를 살펴보겠습니다.

<p align="center">
<img src="https://github.com/Cee/Leetcode/assets/105201451/6134a540-cc71-4aa0-bd60-618b9931c9ba" width="300" height="200"/>

### **1) 대칭키 암호화 방식**

대칭키 암호화 방식이란 **하나의 암호화키(key)**로 평문을 암호화하고, 다시 암호문을 원해의 평문으로 복호화할 때 사용하는 방식입니다. 

키를 단 하나만 사용하는 간편함이 있지만, 키를 분실하거나 도난을 당한다면 내 암호문을 누군가가 복호화하여 볼 수 있다는 치명적인 **단점**이 있습니다.

### **2) 공개키 암호화 방식**

공개키 암호화 방식은 **공개키, 개인키** 이렇게 두 개의 키를 한 쌍(키페어: key pair)으로 각각 암호화/복호화에 사용합니다. 

일반적으로 **공개키**로 암호화한 것을 **개인키**로 복호화합니다. 개인키를 먼저 만들고, 여기서 공개키를 파생하여 한 쌍의 키를 만들기 때문에 키페어라고 부릅니다. 만약 같은 쌍이 아닌 다른 키를 사용하려 한다면 암호화/복호화가 불가능합니다.

공개키 방식은 대칭키 방식에 비해 안전하지만, 계산 과정이 복잡하고 연산 도중 컴퓨터의 자원이 많이 사용합니다. 그래서 실제 IT 시스템에서는 공개키 방식과 대칭키 방식을 적절히 혼합하여 사용합니다.

# **SSL 핸드셰이크 과정**

<p align="center">
<img src="https://github.com/Cee/Leetcode/assets/105201451/43b9b3eb-c4df-48c5-960f-3efb758689fa" width="300" height="200"/>

핸드셰이크(handshake)란 악수를 의미하는데요. 브라우저와 웹 서버가 서로 암호화 통신을 시작할 수 있도록 신분을 확인하고, 필요한 정보를 클라이언트와 서버가 주거니 받거니 하는 과정이 악수와 비슷하여 붙여진 이름입니다. 각 단계의 과정을 순서대로 알아보겠습니다.

### **클라이언트: ① 클라이언트에 해당하는 브라우저가 먼저 웹 서버에 접속합니다. (Client Hello)**

웹 사이트 접속에 HTTPS를 사용하는 브라우저는 다음 정보를 Client Hello 단계에서 보냅니다.

- 브라우저가 사용하는 SSL 혹은 TLS 버전 정보
- 브라우저가 지원하는 암호화 방식 모음(cipher suite)
- 브라우저가 순간적으로 생성한 임의의 난수(숫자)
- 만약 이전에 SSL 핸드 셰이크가 완료된 상태라면, 그때 생성된 세션 아이디(Session ID)
- 기타 정보

cipher suite는보안의 궁극적 목표를 달성하기 위해 사용하는 방식을 패키지의 형태로 묶어 놓은 것을 의미합니다. 여기서 보안의 목표는 다음과 같습니다.

- 안전한 키 교환
- 전달 대상 인증
- 암호화 알고리즘
- 메시지 무결성 확인 알고리즘

### **서버: ② 웹 서버는 ①번에 응답하면서 아래 정보를 클라이언트에 제공합니다. (Server Hello)**

- 브라우저의 암호화 방식 정보 중에서 서버가 지원하고 선택한 암호화 방식(cipher suite)
- SSL 인증서 - CA의 비밀키로 암호화되어 발급된 상태입니다. / **서버의 공개키를 담고 있다.**
- 서버가 순간적으로 생성한 임의의 난수(숫자)
- 클라이언트 인증서 요청(선택사항)

### **클라이언트: ③ 브라우저는 서버의 SSL 인증서가 올바른지 확인합니다.**

대부분 **브라우저**에는 공신력 있는 **CA들의 정보와 CA가 만든 공개키가 이미 설치**되어 있습니다. 

서버가 보낸 SSL 인증서가 정말 CA가 만든 것인지를 확인하기 위해, 

내장된 CA 공개키로 암호화된 인증서를 복호화합니다. 정상적으로 복호화되었다면 CA가 발급한 것이 증명되는 셈입니다. 

### **클라이언트: ④ 브라우저는 자신이 생성한 난수와 서버의 난수를 사용하여 premaster secret을 만듭니다.**

웹 서버 인증서에 딸려 온 웹 사이트의 **공개키**로 이것(premaster sercret)을 암호화하여 서버로 전송합니다.

### **서버: ⑤ 서버는 사이트의 비밀키로, 브라우저가 보낸 premaster secret 값을 복호화합니다.**

복호화한 값을 master secret 값으로 저장합니다. 이것을 사용하여 방금 브라우저와 만들어진 연결에 고유한 값을 부여하기 위한 **세션키를 생성**합니다.

 **세션키**는 대칭키 암호화에 사용할 키입니다. 이것으로 브라우저와 서버 사이에 주고받는 데이터를 암호화하고 복호화합니다.

### **서버/클라이언트: ⑥ SSL 핸드셰이크를 종료하고 HTTPS 통신을 시작합니다.**

브라우저와 서버는 SSL 핸드셰이크가 정상적으로 완료되었습니다. 이제는 웹상에서 데이터를 세션키를 사용해 암호화/복호화하며, HTTPS 프로토콜을 통해 주고받을 수 있습니다. 

HTTPS 통신이 완료되는 시점에서 서로에게 공유된 세션키를 폐기합니다. 만약 세션이 여전히 유지되고 있다면 브라우저는 SSL 핸드셰이크 요청이 아닌 세션 ID만 서버에게 알려주면 됩니다. 이 부분은 ①에서 언급했습니다.

SSL 핸드셰이크 과정은 구현체마다 조금씩 다른 옵션을 가지고 있지만, 대부분의 원리는 위의 내용에서 크게 벗어나지 않습니다. 

**SSL 인증서**에는 **대칭키 방식**과 **공개키 방식** 두 개 모두 사용하며, 모든 웹 콘텐츠의 전달을 공개키 방식으로 한다면 웹 서버와 브라우저에 많은 부담이 됩니다. 

그래서 SSL 핸드셰이크 단계까지는 공개키 방식, 그 이후의 HTTPS 통신은 대칭키 방식을 사용합니다.

# **HTTPS를 적용하면 100% 안전할까?**

HTTPS는 웹에서 보안을 적용하기 위한 가장 기본적인 단계이고, 이것으로 모든 보안성이 완벽하게 지켜졌다고 할 순 없습니다. 예를 들면, 웹 서버가 해커의 다양한 공격에 의해 루트 권한을 탈취당했다면, 모든 기밀 데이터를 열람할 수 있는 권한이 넘어갈 수도 있습니다. 또한 **HTTPS는 전달 구간에 대한 보안 기술**인데, 전달 구간 중간에 해커가 중간자 공격을 수행할 수 있는 취약점이 있다면 HTTPS는 유지되지만 전달하는 내용은 고스란히 노출되기 때문입니다.

따라서 인스턴트 메시징 서비스와 같이 개인 간 혹은 그룹 간 대화, 민감한 개인 정보 등의 전달에서는 HTTPS를 적용하면서도, **종단 간 암호화 기술을 추가로 적용**하여 HTTPS가 무력화되어도 노출된 데이터는 암호화를 유지해, 외부로 노출되지 않도록 하는 방법이 일반적으로 쓰입니다.

</details>  


   ------
### [예습]'최범균의 JSP 2.3 웹 프로그래밍 기초부터 중급까지'
- Chapter 1~4
- Chapter 9, 10
- Chapter 14
- Chapter 17~20
