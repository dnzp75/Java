### https의 작동 방식에 대한 조사 (인증기관/서버/클라이언트가 어떤식으로 주고받는지)
<details>
<summary>생각해보고 답 확인</summary>

**HTTPS**

웹에서 정보를 보호하기 위한 가장 기본적인 기술

HTTPS가 어떤 보안 기술로 브라우저와 웹 서버 사이의 통신을 지킬 수 있는지 

# **HTTPS는 무엇인가?**

<p align="center">
<img src="https://github.com/Cee/Leetcode/assets/105201451/50e1cb7a-ab10-45e8-b558-949e3a608852" width="300" height="200"/>
   
HTTPS를 통한 암호화 통신 

웹은 안전한 통신을 위해 정보를 암호화합니다. 

**암호화**란 일반적인 평문을 알아볼 수 없도록 암호화하여 암호문으로 만드는 과정입니다. 

개인 정보가 담긴 평문을 **암호화**하고, 이렇게 만들어진 **암호문을 상대방에게 전달**하면, 상대방은 이를 다시 **복호화** 하여 원래의 **평문으로 열람**할 수 있습니다.

이와 같은 과정을 웹 브라우저와 웹 서버에 사용하는 대표적인 기술이 바로 HTTPS(Hypertext Transfer Protocol Secure)입니다. 인터넷 콘텐츠를 전달하는 TCP 프로토콜의 일종인 HTTP에 S(Secure) 기능을 더한 것

HTTPS의 원천 기술로는 **SSL(Secure Socket Layer)**과 **TLS(Transport Layer Security) 전송 기술**이 있습니다. 

단어에서 알 수 있듯이 안전한 계층(layer)을 웹 통신에 추가하는 방식

. 이 기술을 수행하기 위해 웹 서버에 설치하는 것이 **SSL/TLS 인증서**

# **SSL 인증서와 SSL 핸드셰이크에 탑재된 기술**

SSL 인증서 관련 프로세스에는 아래와 같은 보안 기술이 탑재되어 있습니다.

- 대칭키 암호화 방식
- 비대칭키 암호화 방식
- 통신 대상을 서로가 확인하는 신분 확인
- 믿을 수 있는 SSL 인증서를 위한 디지털 서명
- 디지털 서명을 해주는 인증 기관의 확인
- 공개키를 안전하게 전달하고 공유하기 위한 프로토콜
- 암호화된 메시지의 변조 여부를 확인하는 메시지 무결성 알고리즘

SSL에 사용된 보안 기술은 암호화, 인증, 서명, 공개키, 무결성 확인 등 매우 다양하기에 이것만 잘 이해하고 있어도, 웬만한 IT 보안 기술에 대한 기본은 이해할 수 있습니다. 이 중에서 대표적인 암호화 방식 두 개를 살펴보겠습니다.

<p align="center">
<img src="https://github.com/Cee/Leetcode/assets/105201451/6134a540-cc71-4aa0-bd60-618b9931c9ba" width="300" height="200"/>

### **1) 대칭키 암호화 방식**

대칭키 암호화 방식이란 **하나의 암호화키(key)**로 평문을 암호화하고, 다시 암호문을 원해의 평문으로 복호화할 때 사용하는 방식입니다. 

키를 단 하나만 사용하는 간편함이 있지만, 키를 분실하거나 도난을 당한다면 내 암호문을 누군가가 복호화하여 볼 수 있다는 치명적인 **단점**이 있습니다.

### **2) 공개키 암호화 방식**

공개키 암호화 방식은 **공개키, 개인키** 이렇게 두 개의 키를 한 쌍(키페어: key pair)으로 각각 암호화/복호화에 사용합니다. 

일반적으로 **공개키**로 암호화한 것을 **개인키**로 복호화합니다. 개인키를 먼저 만들고, 여기서 공개키를 파생하여 한 쌍의 키를 만들기 때문에 키페어라고 부릅니다. 만약 같은 쌍이 아닌 다른 키를 사용하려 한다면 암호화/복호화가 불가능합니다.

공개키 방식은 대칭키 방식에 비해 안전하지만, 계산 과정이 복잡하고 연산 도중 컴퓨터의 자원이 많이 사용합니다. 그래서 실제 IT 시스템에서는 공개키 방식과 대칭키 방식을 적절히 혼합하여 사용합니다.

# **SSL 핸드셰이크 과정**

<p align="center">
<img src="https://github.com/Cee/Leetcode/assets/105201451/43b9b3eb-c4df-48c5-960f-3efb758689fa" width="300" height="200"/>

핸드셰이크(handshake)란 악수를 의미하는데요. 브라우저와 웹 서버가 서로 암호화 통신을 시작할 수 있도록 신분을 확인하고, 필요한 정보를 클라이언트와 서버가 주거니 받거니 하는 과정이 악수와 비슷하여 붙여진 이름입니다. 각 단계의 과정을 순서대로 알아보겠습니다.

### **클라이언트: ① 클라이언트에 해당하는 브라우저가 먼저 웹 서버에 접속합니다. (Client Hello)**

웹 사이트 접속에 HTTPS를 사용하는 브라우저는 다음 정보를 Client Hello 단계에서 보냅니다.

- 브라우저가 사용하는 SSL 혹은 TLS 버전 정보
- 브라우저가 지원하는 암호화 방식 모음(cipher suite)
- 브라우저가 순간적으로 생성한 임의의 난수(숫자)
- 만약 이전에 SSL 핸드 셰이크가 완료된 상태라면, 그때 생성된 세션 아이디(Session ID)
- 기타 정보

cipher suite는보안의 궁극적 목표를 달성하기 위해 사용하는 방식을 패키지의 형태로 묶어 놓은 것을 의미합니다. 여기서 보안의 목표는 다음과 같습니다.

- 안전한 키 교환
- 전달 대상 인증
- 암호화 알고리즘
- 메시지 무결성 확인 알고리즘

### **서버: ② 웹 서버는 ①번에 응답하면서 아래 정보를 클라이언트에 제공합니다. (Server Hello)**

- 브라우저의 암호화 방식 정보 중에서 서버가 지원하고 선택한 암호화 방식(cipher suite)
- SSL 인증서 - CA의 비밀키로 암호화되어 발급된 상태입니다. / **서버의 공개키를 담고 있다.**
- 서버가 순간적으로 생성한 임의의 난수(숫자)
- 클라이언트 인증서 요청(선택사항)

### **클라이언트: ③ 브라우저는 서버의 SSL 인증서가 올바른지 확인합니다.**

대부분 **브라우저**에는 공신력 있는 **CA들의 정보와 CA가 만든 공개키가 이미 설치**되어 있습니다. 

서버가 보낸 SSL 인증서가 정말 CA가 만든 것인지를 확인하기 위해, 

내장된 CA 공개키로 암호화된 인증서를 복호화합니다. 정상적으로 복호화되었다면 CA가 발급한 것이 증명되는 셈입니다. 

### **클라이언트: ④ 브라우저는 자신이 생성한 난수와 서버의 난수를 사용하여 premaster secret을 만듭니다.**

웹 서버 인증서에 딸려 온 웹 사이트의 **공개키**로 이것(premaster sercret)을 암호화하여 서버로 전송합니다.

### **서버: ⑤ 서버는 사이트의 비밀키로, 브라우저가 보낸 premaster secret 값을 복호화합니다.**

복호화한 값을 master secret 값으로 저장합니다. 이것을 사용하여 방금 브라우저와 만들어진 연결에 고유한 값을 부여하기 위한 **세션키를 생성**합니다.

 **세션키**는 대칭키 암호화에 사용할 키입니다. 이것으로 브라우저와 서버 사이에 주고받는 데이터를 암호화하고 복호화합니다.

### **서버/클라이언트: ⑥ SSL 핸드셰이크를 종료하고 HTTPS 통신을 시작합니다.**

브라우저와 서버는 SSL 핸드셰이크가 정상적으로 완료되었습니다. 이제는 웹상에서 데이터를 세션키를 사용해 암호화/복호화하며, HTTPS 프로토콜을 통해 주고받을 수 있습니다. 

HTTPS 통신이 완료되는 시점에서 서로에게 공유된 세션키를 폐기합니다. 만약 세션이 여전히 유지되고 있다면 브라우저는 SSL 핸드셰이크 요청이 아닌 세션 ID만 서버에게 알려주면 됩니다. 이 부분은 ①에서 언급했습니다.

SSL 핸드셰이크 과정은 구현체마다 조금씩 다른 옵션을 가지고 있지만, 대부분의 원리는 위의 내용에서 크게 벗어나지 않습니다. 

**SSL 인증서**에는 **대칭키 방식**과 **공개키 방식** 두 개 모두 사용하며, 모든 웹 콘텐츠의 전달을 공개키 방식으로 한다면 웹 서버와 브라우저에 많은 부담이 됩니다. 

그래서 SSL 핸드셰이크 단계까지는 공개키 방식, 그 이후의 HTTPS 통신은 대칭키 방식을 사용합니다.

# **HTTPS를 적용하면 100% 안전할까?**

HTTPS는 웹에서 보안을 적용하기 위한 가장 기본적인 단계이고, 이것으로 모든 보안성이 완벽하게 지켜졌다고 할 순 없습니다. 예를 들면, 웹 서버가 해커의 다양한 공격에 의해 루트 권한을 탈취당했다면, 모든 기밀 데이터를 열람할 수 있는 권한이 넘어갈 수도 있습니다. 또한 **HTTPS는 전달 구간에 대한 보안 기술**인데, 전달 구간 중간에 해커가 중간자 공격을 수행할 수 있는 취약점이 있다면 HTTPS는 유지되지만 전달하는 내용은 고스란히 노출되기 때문입니다.

따라서 인스턴트 메시징 서비스와 같이 개인 간 혹은 그룹 간 대화, 민감한 개인 정보 등의 전달에서는 HTTPS를 적용하면서도, **종단 간 암호화 기술을 추가로 적용**하여 HTTPS가 무력화되어도 노출된 데이터는 암호화를 유지해, 외부로 노출되지 않도록 하는 방법이 일반적으로 쓰입니다.

</details>

-----
### OSI 7 layer에 대한 조사
<details>
<summary>생각해보고 답 확인</summary>

## [OSI 7계층 흐름 이해(라우터, IP주소)]

**네트워크**

여러 대의 컴퓨터가 서로 **통신**하기 위해 연결되면 그게 바로 네트워크!

### **1) 물리 계층**

(무선 혹은 유선으로)연결되어 있는 A컴퓨터에서 B컴퓨터로 **데이터**를 보낸다고 하자.

<p align="center">
<img src="https://github.com/MentoringOrganization/Java/assets/105201451/3bc50ed5-1cb4-4706-9708-32c823155ff9" width="300" height="200"/>

> 이때, 데이터를 **전기적신호** or **광신호**로 바꾸어 B컴퓨터에 전달하는 **물리적 기술과 장비**들을 다루는 영역을 **1계층** 또는 **물리 계층**이라고 한다.
> 

> 이때, 전기적인 신호(0,1)로 변환해서 주고 받는 기능만 수행한다.
> 

### **2) 데이터 링크 계층**

이렇게 다수의 컴퓨터와 연결이 되면, 서로 다른 컴퓨터들을 구분할 필요가 있다.

그래서 **모든 통신 기기**들은 **서로 구분할 수 있는, 겹치지 않는, 유일한 번호**인 **MAC**(Media Access Control)주소를 가진다.

그래서 각 기기들이 MAC 주소로 구분되고, 서로 통신할 수 있게 된다.

그런데, 네트워크로 연결된 컴퓨터들이 많아질수록 선이 엄청 많이 필요하게 된다.

컴퓨터가 2대라면 단 하나의 선만 필요하지만, 3대라면 3개, 4대라면 6개,,,,,,

이러한 선의 낭비를 줄이기 위해 '허브, **스위치**'라는 장치가 등장했다.

<p align="center">
<img src="https://github.com/MentoringOrganization/Java/assets/105201451/da61ee63-ecd1-4a2a-baca-333cd37cc9cd" width="300" height="200"/>

하지만 또 이렇게 스위치로 모든 컴퓨터 선들이 연결되니, 각 컴퓨터들의 데이터들이 한 곳으로 모여 충돌하면서 여러 문제가 발생한다. (ex) 순서는 어떻게 할지, 동시에 들어오는 데이터들의 충돌은 어떻게 할지 등)

> 그래서 **데이터 링크 계층**, **2계층**에서는 이런 충돌을 피하고 **어떻게 효율적으로 데이터들을 연결하여 통신을 원활하게 할지에 대한 기술과 기계**들을 다루는 영역이다.
> 

> 2계층 : 인접 시스템(네트워크 장치) 간 데이터 전송과 전송 오류를 제어하는 계층
> 

---

### **3) 네트워크 계층**

위와 같이 스위치로 연결된 ABCD 네트워크와 또 다른 스위치로 연결된 A'B'C'D' 네트워크를 **연결**하면 ABCDA'B'C'D'라는 또 하나의 네트워크가 됩니다.

여기까지만 보면 괜찮지만, '**같은 네트워크에 속한 모든 기기**'는 모르는 컴퓨터의 이름(주소)를 알아내기 위해, **연결된**(같은 네트워크에 속한) 모든(broad) 컴퓨터들에게 'x 컴퓨터 주소가 뭐야?'라는 질문을 던지는(cast), **브로드캐스팅**(Broadcasting, 방송)을 합니다.

그런데, 컴퓨터든 스위치든 일정 시간이 지나면 '브로드캐스팅'으로 알아낸 주소를 까먹습니다. 그래서 일정 시간마다 다시 브로드 캐스팅을 하면서 트래픽이 계속 발생하게 됩니다.

전 세계 모든 컴퓨터들을 2계층의 스위치로만 구성한다면, 전 세계 모든 기기들이 같은 네트워크에 속하게 될 것이고, 같은 네트워크에 속했기 때문에 모든 컴퓨터들이 특정시간마다 브로드캐스팅을 보내면, 엄청난 트래픽에 의해 네트워크가 마비될 것입니다.

그러므로 **네트워크를 나눠야 합니다**. 이때, 네트워크를 나눠주는 기기가 바로 **라우터**입니다.

아래와 같이 네트워크와 네트워크 사이에 끼어, **네트워크를 구분하고 또 연결**해줍니다.

<p align="center">
<img src="https://github.com/MentoringOrganization/Java/assets/105201451/73c956d5-48a1-4c3e-a590-44abd9944f9f" width="400" height="200"/>

또한 라우터는 **다른 네트워크까지의 최단 거리를 계산**해서, 목적지 네트워크까지의 최단 거리를 알고 있습니다.

<p align="center">
<img src="https://github.com/MentoringOrganization/Java/assets/105201451/590377a1-f111-4108-892f-551cccdc1974" width="300" height="200"/>

위처럼 A네트워크에 속한 컴퓨터가 F네트워크에 속한 컴퓨터와 **통신**하려고 할 때, 1번 노랑색 길은 라우터 1개를 거쳐가고, 2번 핑크색 길은 라우터 2개를 거쳐간다.

**라우터**는 다른 네트워크까지의 최단 거리를 계산할 수 있으므로, 2번 길이 아닌 1번 길로 보내는 것이 빠르다고 판단하고, 1번 방향으로 A 네트워크의 컴퓨터 패킷(네트워크 계층에서 데이터의 단위)을 F 네트워크로 보낸다는 것이다.

이런 식으로 수많은 라우터와 라우터들이 연결되어 전 세계 모든 네트워크가 연결된 것이 바로 인터네트워크(Internetwork), **인터넷**이다.

그런데, 라우터가 어떻게 길을 찾고, 각각의 네트워크를 구분할까?

현실에서 주소를 통해 길을 찾는 것처럼, 인터넷에서의 구분을 위한 주소가 바로 **IP 주소**이다.

인터넷에선 IP 주소로 모든 것이 구분되고 통신을 하기에, 인터넷을 사용하려면 반드시 IP주소를 할당받아야 한다.

> 이렇게 '네트워크와 네트워크' 사이의 통신에서 사용되는 기술과 장비를 다루는 영역이 **네트워크 계층**, 3계층이다.
> 

그리고, 당연히 네트워크 계층에도 다른 네트워크와의 통신에서 데이터의 충돌, 혼선을 빚지 않게 해주고, 목적지까지 데이터를 잘 전달하게 해 주는 **기술**이 당연히 있다.

컴퓨터 공학에서 이런 기술들을 주로 '**프로토콜**'이라고 한다.

네트워크 계층인 **인터넷에서 네트워크들을 구분하고, 데이터를 효율적인 형태인 '패킷'으로 나눠주는 기술**을 '**IP**(Internet Protocol)'라고 한다.

### **4) 전송 계층**

네트워크를 구분하고, 데이터를 패킷으로 만드는 것은 IP로 해결이 됐지만, 수~많은 라우터들이 연결되어 있는 인터넷은 특정 네트워크까지 패킷을 보내는 방법에 **엄청나게 많은 경우의 수**가 있다.

그러니까 패킷들이 목적지까지 나눠져서 가다가 중간에 특정 길에 문제가 생겨 끊기면 패킷이 소실되는 일도 발생한다는 것이다.

그래서 **기기 종류와 상관없이 네트워크에 접속한 모든 기기들에게 데이터를 안전하게 전송할 수 있는 기술**이 개발되었다. 그게 바로 TCP와 UDP!

> 이렇게 데이터를 어떻게 목적지까지 전송할지에 대한 기술과 장비를 다루는 영역이 **전송 계층**, 4계층이다.
> 

데이터의 확실한 전송을 위해 전송계층에서 '**IP**'와 (**TCP** or **UDP**)를 함께 사용하면 데이터가 중간에 손상되거나 유실되었을 때 다시 보낼 수 있다.

**◆ TCP(Transmission Control Protocol)**

**정확한 데이터를 전송**하는 것이 목적이다. ex) 택배원이 직접 우리 집에 찾아와 내 사인을 받고 택배물을 나에게 전달해주는 것

**3-way-handsahke**

: 'TCP' 통신은 데이터를 전송하기 전에 3가지의 확인 과정을 거친 후에 데이터를 전송한다. 택배원이 우리집(**IP**)으로 찾아와 문을 두들기고(요청) 내가 (대답) 후, 누구냐고 물어보면(요청), 택배원이 '택배입니다' (대답)하면서 **3번 서로의 안전을 확인**한 후, 택배(**데이터)를 받게 된다**. 3-way-handshake로 인해 시간은 다소 걸리지만, 데이터 복구 기능이 있어 데이터를 안전하게 받을 수 있다는 장점이 있다.

**◆ UDP(User Datagram Protocol)**

정확한 **데이터** 배달보다는 **빠른 전송**이 목적이다.  ex) 택배원이 모든 택배물을 경비실에 두고 가는 것

TCP와는 달리 **UDP**는 **스위치**(라우터)의 **브로드캐스트 주소**(경비실)에 그냥 **데이터**(택배)를 보내버린다. 그러면 컴퓨터는 UDP 브로드캐스트를 받아본 다음 자신에게 온 것이면 받고, 아니면 무시한다. 이런 경우 실제와 마찬가지고, 택배(데이터)가 유실되거나 도둑맞아도 택배원은 책임이 없다.

**UDP**를 사용하면, 3- way-handshake가 필요한 TCP와 비교해 **매우매우 빠른 통신**이 가능하지만, 데이터가 제대로 목적지에 전달되었는지 보장할 수 없어 **안전성이 낮다**.

**신뢰성과 안정성**이 중요한 작업이라면 **TCP** 통신을 하고, 동영상과 같이 **빠른 데이터의 전송**이 필요한 작업이라면 **UDP** 통신을 사용한다.

**◆ 포트 번호(Port)**

더 효율적인 통신을 위해 사용하는 '전송 계층'의 기술은 **포트 번호(Port)**이다.

포트 번호는 **컴퓨터의 어느 애플리케이션(응용프로그램)에게 데이터를 전달할지 알려주는 번호**이다.

IP 주소가 아파트의 동번호라면, Port 번호는 아파트의 호수라고 생각하면 된다.

즉, 특정 컴퓨터의 어떤 애플리케이션에게 데이터를 전달하라고 추가적으로 적는 번호가 바로 포트 번호인 것이다.

이렇게 전송 계층에서 목적지 애플리케이션 '**포트번호**'와 '**데이터들의 순서**'를 적고 '**TCP** or **UDP**'를 써서 만든 데이터의 형태를 **세그먼트**라고 한다.

### 세션 계층(Session Layer)

'네트워크 계층의 IP'를 통해 컴퓨터를 찾아가고, '전송 계층의 포트 번호'를 이용해 컴퓨터의 애플리케이션을 찾아가고, '전송 계층의 TCP or UDP'로 안전한/빠른 연결을 확인하였다.

그러고 나면 서버의 애플리케이션과 클라이언트의 애플리케이션 사이에 **데이터 전송을 위한 논리적인 연결통로**가 생긴다.

이 때, 실시간으로 데이터를 주고 받기 위한 두 컴퓨터의 논리적 연결, 만남을 **세션(Session)**이라 하고, 

> 이런 세션을 만들고, 유지, 종료할 때 사용되는 기술과 장비들을 '**세션 계층**'이라고 한다.
> 

### 표현 계층(Presentation Layer)

세션이 만들어지고, 데이터를 전송하려고 하는데, 각 애플리케이션마다 사용하는 데이터 형태가 다르다.

> 그래서 세션을 통해 넘어오는 데이터들을 애플리케이션에서 필요한 형태로 변환(데이터를 어떻게 변환할지 다루는 계층)해 애플리케이션에서 표현하는 계층이기 때문에 '**표현 계층**'이라고 한다.
> 

데이터를 암호화하는 계층이고, 웹에서 흐르는 데이터를 암호화하려면 반드시 표현 계층을 거쳐야 한다.

### 응용 계층(Application Layer)

> 우리가 사용하는 사용자 인터페이스를 제공하는 응용 프로그램들의 상호작용을 다루는 계층이다.
> 

세상에 정말 수없이 많은 응용프로그램이 있듯, 각 응용 프로그램에 사용하는 수많은 프로토콜이 있다.

대표적으로 인터넷상에서 문자(Hyper Text) 데이터를 다루는 프로토콜 **HTTP**, 파일을 주고 받을 때 사용하는 프로토콜 **FTP**, 도메인 네임서버를 찾을 때 사용하는 프로토콜 **DNS**, SSH 연결을 할 때 사용하는 프로토콜 **SSH** 등이 있다.


</details>

