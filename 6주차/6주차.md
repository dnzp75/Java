### https의 작동 방식에 대한 조사 (인증기관/서버/클라이언트가 어떤식으로 주고받는지)
<details>
<summary>생각해보고 답 확인</summary>

**HTTPS**

웹에서 정보를 보호하기 위한 가장 기본적인 기술

HTTPS가 어떤 보안 기술로 브라우저와 웹 서버 사이의 통신을 지킬 수 있는지 

# **HTTPS는 무엇인가?**

<p align="center">
<img src="https://github.com/Cee/Leetcode/assets/105201451/50e1cb7a-ab10-45e8-b558-949e3a608852" width="300" height="200"/>
   
HTTPS를 통한 암호화 통신 

웹은 안전한 통신을 위해 정보를 암호화합니다. 

**암호화**란 일반적인 평문을 알아볼 수 없도록 암호화하여 암호문으로 만드는 과정입니다. 

개인 정보가 담긴 평문을 **암호화**하고, 이렇게 만들어진 **암호문을 상대방에게 전달**하면, 상대방은 이를 다시 **복호화** 하여 원래의 **평문으로 열람**할 수 있습니다.

이와 같은 과정을 웹 브라우저와 웹 서버에 사용하는 대표적인 기술이 바로 HTTPS(Hypertext Transfer Protocol Secure)입니다. 인터넷 콘텐츠를 전달하는 TCP 프로토콜의 일종인 HTTP에 S(Secure) 기능을 더한 것

HTTPS의 원천 기술로는 **SSL(Secure Socket Layer)**과 **TLS(Transport Layer Security) 전송 기술**이 있습니다. 

단어에서 알 수 있듯이 안전한 계층(layer)을 웹 통신에 추가하는 방식

. 이 기술을 수행하기 위해 웹 서버에 설치하는 것이 **SSL/TLS 인증서**

# **SSL 인증서와 SSL 핸드셰이크에 탑재된 기술**

SSL 인증서 관련 프로세스에는 아래와 같은 보안 기술이 탑재되어 있습니다.

- 대칭키 암호화 방식
- 비대칭키 암호화 방식
- 통신 대상을 서로가 확인하는 신분 확인
- 믿을 수 있는 SSL 인증서를 위한 디지털 서명
- 디지털 서명을 해주는 인증 기관의 확인
- 공개키를 안전하게 전달하고 공유하기 위한 프로토콜
- 암호화된 메시지의 변조 여부를 확인하는 메시지 무결성 알고리즘

SSL에 사용된 보안 기술은 암호화, 인증, 서명, 공개키, 무결성 확인 등 매우 다양하기에 이것만 잘 이해하고 있어도, 웬만한 IT 보안 기술에 대한 기본은 이해할 수 있습니다. 이 중에서 대표적인 암호화 방식 두 개를 살펴보겠습니다.

<p align="center">
<img src="https://github.com/Cee/Leetcode/assets/105201451/6134a540-cc71-4aa0-bd60-618b9931c9ba" width="300" height="200"/>

### **1) 대칭키 암호화 방식**

대칭키 암호화 방식이란 **하나의 암호화키(key)**로 평문을 암호화하고, 다시 암호문을 원해의 평문으로 복호화할 때 사용하는 방식입니다. 

키를 단 하나만 사용하는 간편함이 있지만, 키를 분실하거나 도난을 당한다면 내 암호문을 누군가가 복호화하여 볼 수 있다는 치명적인 **단점**이 있습니다.

### **2) 공개키 암호화 방식**

공개키 암호화 방식은 **공개키, 개인키** 이렇게 두 개의 키를 한 쌍(키페어: key pair)으로 각각 암호화/복호화에 사용합니다. 

일반적으로 **공개키**로 암호화한 것을 **개인키**로 복호화합니다. 개인키를 먼저 만들고, 여기서 공개키를 파생하여 한 쌍의 키를 만들기 때문에 키페어라고 부릅니다. 만약 같은 쌍이 아닌 다른 키를 사용하려 한다면 암호화/복호화가 불가능합니다.

공개키 방식은 대칭키 방식에 비해 안전하지만, 계산 과정이 복잡하고 연산 도중 컴퓨터의 자원이 많이 사용합니다. 그래서 실제 IT 시스템에서는 공개키 방식과 대칭키 방식을 적절히 혼합하여 사용합니다.

# **SSL 핸드셰이크 과정**

<p align="center">
<img src="https://github.com/Cee/Leetcode/assets/105201451/43b9b3eb-c4df-48c5-960f-3efb758689fa" width="300" height="200"/>

핸드셰이크(handshake)란 악수를 의미하는데요. 브라우저와 웹 서버가 서로 암호화 통신을 시작할 수 있도록 신분을 확인하고, 필요한 정보를 클라이언트와 서버가 주거니 받거니 하는 과정이 악수와 비슷하여 붙여진 이름입니다. 각 단계의 과정을 순서대로 알아보겠습니다.

### **클라이언트: ① 클라이언트에 해당하는 브라우저가 먼저 웹 서버에 접속합니다. (Client Hello)**

웹 사이트 접속에 HTTPS를 사용하는 브라우저는 다음 정보를 Client Hello 단계에서 보냅니다.

- 브라우저가 사용하는 SSL 혹은 TLS 버전 정보
- 브라우저가 지원하는 암호화 방식 모음(cipher suite)
- 브라우저가 순간적으로 생성한 임의의 난수(숫자)
- 만약 이전에 SSL 핸드 셰이크가 완료된 상태라면, 그때 생성된 세션 아이디(Session ID)
- 기타 정보

cipher suite는보안의 궁극적 목표를 달성하기 위해 사용하는 방식을 패키지의 형태로 묶어 놓은 것을 의미합니다. 여기서 보안의 목표는 다음과 같습니다.

- 안전한 키 교환
- 전달 대상 인증
- 암호화 알고리즘
- 메시지 무결성 확인 알고리즘

### **서버: ② 웹 서버는 ①번에 응답하면서 아래 정보를 클라이언트에 제공합니다. (Server Hello)**

- 브라우저의 암호화 방식 정보 중에서 서버가 지원하고 선택한 암호화 방식(cipher suite)
- SSL 인증서 - CA의 비밀키로 암호화되어 발급된 상태입니다. / **서버의 공개키를 담고 있다.**
- 서버가 순간적으로 생성한 임의의 난수(숫자)
- 클라이언트 인증서 요청(선택사항)

### **클라이언트: ③ 브라우저는 서버의 SSL 인증서가 올바른지 확인합니다.**

대부분 **브라우저**에는 공신력 있는 **CA들의 정보와 CA가 만든 공개키가 이미 설치**되어 있습니다. 

서버가 보낸 SSL 인증서가 정말 CA가 만든 것인지를 확인하기 위해, 

내장된 CA 공개키로 암호화된 인증서를 복호화합니다. 정상적으로 복호화되었다면 CA가 발급한 것이 증명되는 셈입니다. 

### **클라이언트: ④ 브라우저는 자신이 생성한 난수와 서버의 난수를 사용하여 premaster secret을 만듭니다.**

웹 서버 인증서에 딸려 온 웹 사이트의 **공개키**로 이것(premaster sercret)을 암호화하여 서버로 전송합니다.

### **서버: ⑤ 서버는 사이트의 비밀키로, 브라우저가 보낸 premaster secret 값을 복호화합니다.**

복호화한 값을 master secret 값으로 저장합니다. 이것을 사용하여 방금 브라우저와 만들어진 연결에 고유한 값을 부여하기 위한 **세션키를 생성**합니다.

 **세션키**는 대칭키 암호화에 사용할 키입니다. 이것으로 브라우저와 서버 사이에 주고받는 데이터를 암호화하고 복호화합니다.

### **서버/클라이언트: ⑥ SSL 핸드셰이크를 종료하고 HTTPS 통신을 시작합니다.**

브라우저와 서버는 SSL 핸드셰이크가 정상적으로 완료되었습니다. 이제는 웹상에서 데이터를 세션키를 사용해 암호화/복호화하며, HTTPS 프로토콜을 통해 주고받을 수 있습니다. 

HTTPS 통신이 완료되는 시점에서 서로에게 공유된 세션키를 폐기합니다. 만약 세션이 여전히 유지되고 있다면 브라우저는 SSL 핸드셰이크 요청이 아닌 세션 ID만 서버에게 알려주면 됩니다. 이 부분은 ①에서 언급했습니다.

SSL 핸드셰이크 과정은 구현체마다 조금씩 다른 옵션을 가지고 있지만, 대부분의 원리는 위의 내용에서 크게 벗어나지 않습니다. 

**SSL 인증서**에는 **대칭키 방식**과 **공개키 방식** 두 개 모두 사용하며, 모든 웹 콘텐츠의 전달을 공개키 방식으로 한다면 웹 서버와 브라우저에 많은 부담이 됩니다. 

그래서 SSL 핸드셰이크 단계까지는 공개키 방식, 그 이후의 HTTPS 통신은 대칭키 방식을 사용합니다.

# **HTTPS를 적용하면 100% 안전할까?**

HTTPS는 웹에서 보안을 적용하기 위한 가장 기본적인 단계이고, 이것으로 모든 보안성이 완벽하게 지켜졌다고 할 순 없습니다. 예를 들면, 웹 서버가 해커의 다양한 공격에 의해 루트 권한을 탈취당했다면, 모든 기밀 데이터를 열람할 수 있는 권한이 넘어갈 수도 있습니다. 또한 **HTTPS는 전달 구간에 대한 보안 기술**인데, 전달 구간 중간에 해커가 중간자 공격을 수행할 수 있는 취약점이 있다면 HTTPS는 유지되지만 전달하는 내용은 고스란히 노출되기 때문입니다.

따라서 인스턴트 메시징 서비스와 같이 개인 간 혹은 그룹 간 대화, 민감한 개인 정보 등의 전달에서는 HTTPS를 적용하면서도, **종단 간 암호화 기술을 추가로 적용**하여 HTTPS가 무력화되어도 노출된 데이터는 암호화를 유지해, 외부로 노출되지 않도록 하는 방법이 일반적으로 쓰입니다.

</details>

-----
### OSI 7 layer에 대한 조사
<details>
<summary>생각해보고 답 확인</summary>

# **OSI 7 Layer**

`OSI 7계층` 이란 네트워크 통신을 수행할 때, 처리되어야 할 작업을 순차적으로 7단계로 처리 하는 과정을 의미합니다.

계층을 나누어 처리함으로써, 필요한 작업들은 독립적인 모듈로 처리 됩니다. 이는 디버깅이 용이하고 모듈간 교체 및 확장등이 자유롭다는 장점이 존재합니다.

`OSI 1~3 계층`은 **하드웨어 영역**으로써, 각 층마다 매칭되는 하드웨어 장치가 존재합니다. 따라서, 해당 계층의 역할들은 **하드웨어가 실질적으로 수행하는 역할** 입니다.

`OSI 4~7 계층`은 **소프트웨어 영역**이며, `4~6 계층`은 **OS**가 `7계층`은 우리가 사용하는 **프로그램**이 해당 계층의 역할을 수행합니다.

다음 이미지는 OSI 7계층 구성도 입니다.

<p align="center">
<img src="https://github.com/Cee/Leetcode/assets/105201451/eb6a2f75-943c-4099-b6b6-d0dd30c8ca85" width="300" height="200"/>

---

# **Physical Layer**

네트워크 통신은 서로 멀리 떨어져 있는 지점끼리 데이터를 주고 받을 수 있습니다. 데이터 통신은 아날로그 신호(주파수)로 최초 전달 되고 디지털 데이터로 변환되어 해석하는것을 의미합니다.

`물리 계층(Physical Layer)`은 이러한 아날로그 신호(주파수)를 디지털 신호로 변경해주는 역할을 수행합니다.

`물리 계층`의 역할은 여러 하드웨어의 조합으로 수행됩니다. 아날로그 신호를 디지털 테이터로 변환하는 주된 역할은 **NIC(Network Interface Controller)**란 하드웨어가 수행합니다. 흔히 **네트워크 카드**, **랜 카드**로 불립니다.

# **Data-Link Layer**

네트워크 통신은 여러 프로그램이 동시적, 지속적으로 수행 할 수 있습니다. 이때, 컴퓨터는 들어온 데이터를 식별하기 위한 라벨링 작업이 필요합니다. 이러한 행위를 **프레임화** 라고 부릅니다.

`데이터 링크 계층(Data-Link Layer)`은 **프레임화**를 진행하고, 만들어진 **프레임**을 상위 계층 또는 하위 계층에 전달 합니다.

결론적으로, 해당 계층은 두가지 역할로 정리할 수 있습니다.

- **프레임화** (데이터 라벨링)
- **흐름제어** (상위 계층 또는 하위 계층으로 프레임 전달)
    
    > 3계층, 1계층도 하드웨어 영역이므로 인접한 네트워크 장비에 데이터를 전송하는것을 의미합니다.
    > 

해당 계층의 역할을 수행하는 대표적인 하드웨어는 위에서 언급한 **NIC** 입니다. 해당 계층의 역할을 전문적으로 수행하는 **브릿지**, **스위치** 같은 장비들도 존재합니다.

# **Network Layer**

`물리 계층`의 아날로그 신호는 거리가 먼 지점까지 전달되지 않습니다.

신호를 세게 하는 **리피터**라는 장비를 사용 할 수 있지만, 이는 특정 지점에 전달 하기 보다 무분별하게 전파하기 때문에 효율이 떨어 집니다.

이를 해결하기 위해 사용되는 장비는 바로 **라우터** 입니다. 무분별하게 전파하는 **리피터**와는 다르게 **라우터**는 내장된 **라우팅 알고리즘**을 통해 전달 할 수 있는 가장 가까운 **라우터** 까지의 경로를 결정하고 이를 테이블로 저장합니다. 해당 행위를 **라우팅** 이라 표현 합니다.

경로가 결정되면 전달해야할 데이터를 다음 라우터에게 맡깁니다. N개의 라우터가 지속적으로 정보를 전달을 하면서 최종 목적지 까지 전달하는 방법을 **포워딩** 이라 표현 합니다.

이때, 정보를 전달 받은 라우터는 본인이 최종 목적지 인지 여부와 응답 데이터를 다시 출발지 라우터로 보내기 위한 데이터가 필요합니다. 즉 전달해야 하는 데이터는 출발지 정보, 목적지 정보가 부가적으로 필요 하며 해당 정보는 **IP** 라는 정보로 처리합니다. 전달 데이터에 **IP** 정보를 붙인 데이터를 **패킷** 이라 부릅니다.

정리하자면 해당 계층은 3가지 역할을 수행합니다.

- 2계층에서 넘어온 데이터를 **패킷**으로 만들거나, 수신된 **패킷** 데이터를 해석합니다.
- 다음 라우터의 경로를 찾기 위한 **라우팅**을 진행합니다.
- **패킷** 전달의 역할을 다음 **라우터**에게 위임하는 **포워딩**을 진행합니다.

해당 계층에 대표적인 하드웨어는 위에서 언급했던 **라우터** 이며 우리가 집에서 흔히 사용하는 **공유기**도 **라우터**의 역할을 어느정도 수행 합니다.

# **Transport Layer**

데이터 통신은 여러 프로그램이 동시에 지속적으로 수행되고 있습니다.

그렇기에 특정 데이터가 어떤 프로그램과 관련이 있는지 식별할 수 있어야 합니다.

식별하기 위해 **포트번호** 라는 데이터가 사용됩니다.

`전송 계층(Transport Layer)`은 하위 계층에 데이터를 전달 할때 데이터에 **포트번호**를 붙이며, 하위 계층으로 부터 데이터를 전달 받을 때도 **포트번호** 를 통해 데이터를 식별합니다.

또한 **데이터 통신 프로토콜에 따른 알고리즘이 수행**됩니다. 대표적인 예로 **TCP**, **UDP** 프로토콜이 존재합니다.

**TCP** 통신이 제공하는 **연결지향**, **흐름제어**, **오류검출 및 회복** 등이 해당 계층에서 수행됩니다.

해당 계층의 역할은 운영체제 커널에 소프트웨어적으로 구현되어 있습니다.

정리하자면 해당 계층은 크게 2가지 역할을 수행합니다.

- **포트번호**를 통한 데이터 식별 작업.
- 데이터 통신 프로토콜에 따른 알고리즘 수행.

# **Session Layer**

> Warning!
> 

`세션 계층(Session Layer)`의 주된 목표는 각 프로그램의 **네트워크 통신 상태 관리**와 **동기화** 입니다.

**상태 관리**는 데이터 통신 프로토콜 알고리즘이 가지는 특성들을 수행하기 위해 필요한 처리를 의미합니다. 예를들어 TCP 프로토콜은 연결 수립, 종료와 같은 상태 등을 처리합니다.

**동기화**란 `전송 계층`에서 올라온 또는 `응용 계층` 에서 내려온 데이터를 안정적으로 상위 또는 하위 계층으로 전달하는 역할을 수행합니다. 데이터가 성공적으로 전달된 지점까지 내부적으로 마킹해두며, 데이터 전달에 문제가 발생하면 마킹한 지점부터 오류지점까지 데이터 복구 절차가 수행됩니다.

해당 계층 역할도 운영체제가 수행합니다.

# **Presentation Layer**

`표현 계층(Presentation Layer)`은 하위 계층이 전달한 데이터를 어플리케이션이 해석 할 수 있도록 데이터를 **디코딩** 하거나, 데이터 전달을 효율적으로 수행하기 위해 데이터를 **인코딩** 한 뒤 하위 계층으로 전달합니다.

다음은 표현 계층이 수행하는 대표적인 예시 입니다.

- SSL 프로토콜에서 처리되는 **암, 복호화 처리**
- 데이터 **압축**및 **해제** 처리
- 데이터 포맷(UTF-8 과 같은)에 따른 **인코딩**, **디코딩** 처리

해당 계층 역할 역시 운영체제가 수행합니다.

# **Application Layer**

`응용 계층(Application Layer)`은 요구사항을 처리하기 위해 네트워크 통신을 이용한 데이터의 송-수신이 발생하는 가장 마지막 영역 입니다.

운영체제는 `전송 계층`에서 제공하는 API를 활용하여 네트워크 통신을 가능토록 API를 제공하는데, 이를 **소켓 API**라 부릅니다.

해당 계층은 **소켓 프로그래밍**을 통해 데이터를 **송신 및 수신**을 수행합니다.

재밌는 특징은 각 프로그램이 개별적으로 데이터 규격을 만들어 통신 할 수 있습니다. 데이터의 인코딩 및 디코딩을 각 프로그램이 자체적으로 수행할 수 있기 때문입니다.

프로그램이 대표적으로 사용하는 데이터 규격은 **HTTP 프로토콜** 방식이 있으며 작은 단위로는 **JSON**, **XML**과 같은 데이터 규격도 존재합니다.

해당 계층의 역할은 개발된 프로그램이 수행합니다.

# **TCP/IP 모델의 등장**

독립적인 모듈을 구성하는것은 정답이 존재하지 않습니다. 나뉘어진 모듈이 서로 심하게 의존하는 경우 모듈의 **결합도**가 높다고 하며, 모듈이 너무 작은 단위로 구성 된 경우 **응집도**가 떨어진다고 합니다. 이러한 특징들은 소프트웨어적 가치를 하락시키는 요인입니다.

`OSI 7계층`은 대표적인 네트워크 통신 규격으로 사용 되고 있지만, `OSI 7계층`역시 결합도가 높고, 응집도가 낮은 모듈들이 존재합니다.

그 대상 계층들은 `응용 계층`, `표현 계층`, `세션 계층` 입니다. 따라서 현대적인 네트워크 통신 규격인 `TCP/IP 모델` 은 다음과 같이 정의 되었습니다.

<p align="center">
<img src="https://github.com/Cee/Leetcode/assets/105201451/4113345f-27c5-4eaa-98d8-9babd13cf67d" width="300" height="200"/>

`TCP/IP 모델`의 `네트워크 엑세스 계층`은 `데이터 링크 계층` + `물리 계층` 으로 나누어서 표현하기도 합니다.

반면에 `응용 계층`, `표현 계층`, `세션 계층` 들은 `응용 계층` 하나로 통합 되었습니다.

---

`TCP/IP 모델`의 각 계층 역할도 `OSI 7계층`의 역할과 동일합니다.

몇몇 모듈이 독립적으로 수행되던 역할이 하나의 모듈이 통합 수행 한다고 이해


</details>

