### https의 작동 방식에 대한 조사 (인증기관/서버/클라이언트가 어떤식으로 주고받는지)

<details>
<summary>생각해보고 답 확인</summary>

 ### 1. 클라이언트가 서버로 **hello 메세지를 전송**하면서 웹 서버에 접속 시작

  **hello** **메세지**

 [ 클라이언트가 지원하는 TLS(SSL) 버전 ] / [ 지원되는 암호 제품군 ]

 [ 브라우저가 순간적으로 생성한 임의의 **난수(숫자)** ]

### 2. 서버는 클라이언트 hello 메시지에 대한 응답으로 **메시지를 전송**

**응답 메시지**

[ 서버의 SSL 인증서 ] / [ 서버에서 선택한 암호 제품군 ]

[ 서버가 순간적으로 생성한 임의의 **난수(숫자)** ]

### 4. 클라이언트가 서버의 SSL 인증서를 인증서 발행 기관(CA)을 통해 검증

[ SSL 인증서 ]
 서비스의 정보(인증서를 발급한 CA, 서비스의 도메인 등) /  서버의 공개키가 포함
< CA의 비밀키> 에 의해 암호화된 SSL 인증서

- 브라우저는 신뢰된 < CA 기업의 공개키> 는 모두 보유

- 서버가 보낸 SSL 인증서가 정말 CA가 만든 것인지를 확인하기 위해,

- 내장된 CA 공개키로 암호화된 인증서를 복호화합니다. 정상적으로 복호화되었다면 CA가 발급한 것이 증명되는 셈

※ CA -> 서버의 공개키를 저장해주는 신뢰성이 검증된 민간 기업

### 5. **브라우저는 자신이 생성한 난수와 서버의 난수를 사용하여 premaster secret을 만들고** SSL 인증서에 딸려 온 웹 사이트의 **공개키**로 이것(premaster sercret)을 암호화하여 서버로 전송

### 6. **서버는 사이트의 비밀키로, 브라우저가 보낸 premaster secret 값을 복호화합니다.**

- 복호화한 값을 master secret 값으로 저장

- 이것을 사용하여 **방금 브라우저와 만들어진 연결에 고유한 값을 부여**하기 위한 **세션키를 생성**합니다.

- **세션키**는 대칭키 암호화에 사용할 키입니다. 이것으로 브라우저와 서버 사이에 주고받는 데이터를 암호화하고 복호화합니다.

### 7. **서버/클라이언트: ⑥ SSL 핸드셰이크를 종료하고 HTTPS 통신을 시작합니다.**

 - 이제는 웹 상에서 데이터를 **세션키**를 사용해 암호화/복호화하며, HTTPS 프로토콜을 통해 주고받을 수 있습니다.

</details>

-----
### OSI 7 layer에 대한 조사

<details>
<summary>생각해보고 답 확인</summary>

OSI 7계층은 물리 계층, 데이터 링크 계층, 네트워크 계층, 전송 계층, 세션 계층, 표현 계층, 응용 계층으로 구성되어 있습니다.

**물리 계층**

 0과 1로 구성된 데이터를 선으로 전달할 수 있도록 전기적인 신호로 변환시켜주는 역할을 합니다.

**데이터 링크 계층**

point to point같은 LAN 안의 연결된 컴퓨터들끼리 MAC 주소로 통신이 가능하게 해줍니다. 이 계층에서 전송되는 단위를 프레임이라고 하고 장비로는 스위치가 있습니다.

**네트워크 계층**

 라우터 장비를 이용해 데이터를 목적지까지 안전하고 가장 빠른 경로로 전달해주는 역할을 합니다. IP 주소를 이용해 다른 LAN에 속한 컴퓨터로 데이터를 전송할 수 있습니다.

**전송 계층**

End to End 양 끝단의 사용자들이 신뢰성 있는 데이터를 주고 받을 수 있도록 해줍니다. 또한 포트번호로 데이터의 목적지가 어느 애플리케이션인지 식별할 수 있습니다. 대표적인 프로토콜로는 TCP, UDP가 있습니다.

**세션 계층**

양 끝단의 응용 프로세스가 통신을 하기 위한 방법을 제공합니다. TCP/IP 세션을 생성하고 없애는 책임이 있습니다.

**표현 계층**

데이터 표현에 대한 독립성 제공과 암호화 역할을 담당합니다.

**응용 계층**

최종 목적지로 응용 프로세스와 직접 관계하여 일반적인 응용 서비스를 수행합니다.

</details>

### [OSI 7계층 흐름 이해(라우터, IP주소)]
<details>
<summary>생각해보고 답 확인</summary>


**네트워크**

여러 대의 컴퓨터가 서로 **통신**하기 위해 연결되면 그게 바로 네트워크!

### **1) 물리 계층**

(무선 혹은 유선으로)연결되어 있는 A컴퓨터에서 B컴퓨터로 **데이터**를 보낸다고 하자.

<p align="center">
<img src="https://github.com/MentoringOrganization/Java/assets/105201451/3bc50ed5-1cb4-4706-9708-32c823155ff9" width="300" height="200"/>
 

 [ 이때, 데이터를 **전기적신호** or **광신호**로 바꾸어 B컴퓨터에 전달하는 **물리적 기술과 장비**들을 다루는 영역을 **1계층** 또는 **물리 계층**이라고 한다. ]

 [ 이때, 전기적인 신호(0,1)로 변환해서 주고 받는 기능만 수행한다. ]


### **2) 데이터 링크 계층**

이렇게 다수의 컴퓨터와 연결이 되면, 서로 다른 컴퓨터들을 구분할 필요가 있다.

그래서 **모든 통신 기기**들은 **서로 구분할 수 있는, 겹치지 않는, 유일한 번호**인 **MAC**(Media Access Control)주소를 가진다.

그래서 각 기기들이 MAC 주소로 구분되고, 서로 통신할 수 있게 된다.

그런데, 네트워크로 연결된 컴퓨터들이 많아질수록 선이 엄청 많이 필요하게 된다.

컴퓨터가 2대라면 단 하나의 선만 필요하지만, 3대라면 3개, 4대라면 6개,,,,,,

이러한 선의 낭비를 줄이기 위해 '허브, **스위치**'라는 장치가 등장했다.

<p align="center">
<img src="https://github.com/MentoringOrganization/Java/assets/105201451/da61ee63-ecd1-4a2a-baca-333cd37cc9cd" width="300" height="200"/>

하지만 또 이렇게 스위치로 모든 컴퓨터 선들이 연결되니, 각 컴퓨터들의 데이터들이 한 곳으로 모여 충돌하면서 여러 문제가 발생한다. (ex) 순서는 어떻게 할지, 동시에 들어오는 데이터들의 충돌은 어떻게 할지 등)

[ 그래서 **데이터 링크 계층**, **2계층**에서는 이런 충돌을 피하고 **어떻게 효율적으로 데이터들을 연결하여 통신을 원활하게 할지에 대한 기술과 기계**들을 다루는 영역이다. ]
 
[ 2계층 : 인접 시스템(네트워크 장치) 간 데이터 전송과 전송 오류를 제어하는 계층 ]


---

### **3) 네트워크 계층**

위와 같이 스위치로 연결된 ABCD 네트워크와 또 다른 스위치로 연결된 A'B'C'D' 네트워크를 **연결**하면 ABCDA'B'C'D'라는 또 하나의 네트워크가 됩니다.

여기까지만 보면 괜찮지만, '**같은 네트워크에 속한 모든 기기**'는 모르는 컴퓨터의 이름(주소)를 알아내기 위해, **연결된**(같은 네트워크에 속한) 모든(broad) 컴퓨터들에게 'x 컴퓨터 주소가 뭐야?'라는 질문을 던지는(cast), **브로드캐스팅**(Broadcasting, 방송)을 합니다.

그런데, 컴퓨터든 스위치든 일정 시간이 지나면 '브로드캐스팅'으로 알아낸 주소를 까먹습니다. 그래서 일정 시간마다 다시 브로드 캐스팅을 하면서 트래픽이 계속 발생하게 됩니다.

전 세계 모든 컴퓨터들을 2계층의 스위치로만 구성한다면, 전 세계 모든 기기들이 같은 네트워크에 속하게 될 것이고, 같은 네트워크에 속했기 때문에 모든 컴퓨터들이 특정시간마다 브로드캐스팅을 보내면, 엄청난 트래픽에 의해 네트워크가 마비될 것입니다.

그러므로 **네트워크를 나눠야 합니다**. 이때, 네트워크를 나눠주는 기기가 바로 **라우터**입니다.

아래와 같이 네트워크와 네트워크 사이에 끼어, **네트워크를 구분하고 또 연결**해줍니다.

<p align="center">
<img src="https://github.com/MentoringOrganization/Java/assets/105201451/73c956d5-48a1-4c3e-a590-44abd9944f9f" width="400" height="200"/>

또한 라우터는 **다른 네트워크까지의 최단 거리를 계산**해서, 목적지 네트워크까지의 최단 거리를 알고 있습니다.

<p align="center">
<img src="https://github.com/MentoringOrganization/Java/assets/105201451/590377a1-f111-4108-892f-551cccdc1974" width="300" height="200"/>


이런 식으로 수많은 라우터와 라우터들이 연결되어 전 세계 모든 네트워크가 연결된 것이 바로 인터네트워크(Internetwork), **인터넷**이다.

그런데, 라우터가 어떻게 길을 찾고, 각각의 네트워크를 구분할까?

현실에서 주소를 통해 길을 찾는 것처럼, 인터넷에서의 구분을 위한 주소가 바로 **IP 주소**이다.

인터넷에선 IP 주소로 모든 것이 구분되고 통신을 하기에, 인터넷을 사용하려면 반드시 IP주소를 할당받아야 한다.

[ 이렇게 '네트워크와 네트워크' 사이의 통신에서 사용되는 기술과 장비를 다루는 영역이 **네트워크 계층**, 3계층이다. ] 

그리고, 당연히 네트워크 계층에도 다른 네트워크와의 통신에서 데이터의 충돌, 혼선을 빚지 않게 해주고, 목적지까지 데이터를 잘 전달하게 해 주는 것이 **프로토콜 기술**

네트워크 계층인 **인터넷에서 네트워크들을 구분하고, 데이터를 효율적인 형태인 '패킷'으로 나눠주는 기술**을 '**IP**(Internet Protocol)'라고 한다.

### **4) 전송 계층**

네트워크를 구분하고, 데이터를 패킷으로 만드는 것은 IP로 해결이 됐지만, 수~많은 라우터들이 연결되어 있는 인터넷은 특정 네트워크까지 패킷을 보내는 방법에 **엄청나게 많은 경우의 수**가 있다.

그러니까 패킷들이 목적지까지 나눠져서 가다가 중간에 특정 길에 문제가 생겨 끊기면 패킷이 소실되는 일도 발생한다는 것이다.

그래서 **기기 종류와 상관없이 네트워크에 접속한 모든 기기들에게 데이터를 안전하게 전송할 수 있는 기술**이 개발되었다. 그게 바로 TCP와 UDP!

[ 이렇게 데이터를 어떻게 목적지까지 전송할지에 대한 기술과 장비를 다루는 영역이 **전송 계층**, 4계층이다. ]

데이터의 확실한 전송을 위해 전송계층에서 '**IP**'와 (**TCP** or **UDP**)를 함께 사용하면 데이터가 중간에 손상되거나 유실되었을 때 다시 보낼 수 있다.

**◆ TCP(Transmission Control Protocol)**

**정확한 데이터를 전송**하는 것이 목적이다. ex) 택배원이 직접 우리 집에 찾아와 내 사인을 받고 택배물을 나에게 전달해주는 것

**3-way-handsahke**

: 'TCP' 통신은 데이터를 전송하기 전에 3가지의 확인 과정을 거친 후에 데이터를 전송한다. 택배원이 우리집(**IP**)으로 찾아와 문을 두들기고(요청) 내가 (대답) 후, 누구냐고 물어보면(요청), 택배원이 '택배입니다' (대답)하면서 **3번 서로의 안전을 확인**한 후, 택배(**데이터)를 받게 된다**. 3-way-handshake로 인해 시간은 다소 걸리지만, 데이터 복구 기능이 있어 데이터를 안전하게 받을 수 있다는 장점이 있다.

**◆ UDP(User Datagram Protocol)**

정확한 **데이터** 배달보다는 **빠른 전송**이 목적이다.  ex) 택배원이 모든 택배물을 경비실에 두고 가는 것

TCP와는 달리 **UDP**는 **스위치**(라우터)의 **브로드캐스트 주소**(경비실)에 그냥 **데이터**(택배)를 보내버린다. 그러면 컴퓨터는 UDP 브로드캐스트를 받아본 다음 자신에게 온 것이면 받고, 아니면 무시한다. 이런 경우 실제와 마찬가지고, 택배(데이터)가 유실되거나 도둑맞아도 택배원은 책임이 없다.

**UDP**를 사용하면, 3- way-handshake가 필요한 TCP와 비교해 **매우매우 빠른 통신**이 가능하지만, 데이터가 제대로 목적지에 전달되었는지 보장할 수 없어 **안전성이 낮다**.

**신뢰성과 안정성**이 중요한 작업이라면 **TCP** 통신을 하고, 동영상과 같이 **빠른 데이터의 전송**이 필요한 작업이라면 **UDP** 통신을 사용한다.

**◆ 포트 번호(Port)**

더 효율적인 통신을 위해 사용하는 '전송 계층'의 기술은 **포트 번호(Port)**이다.

포트 번호는 **컴퓨터의 어느 애플리케이션(응용프로그램)에게 데이터를 전달할지 알려주는 번호**이다.

IP 주소가 아파트의 동번호라면, Port 번호는 아파트의 호수라고 생각하면 된다.

즉, 특정 컴퓨터의 어떤 애플리케이션에게 데이터를 전달하라고 추가적으로 적는 번호가 바로 포트 번호인 것이다.

이렇게 전송 계층에서 목적지 애플리케이션 '**포트번호**'와 '**데이터들의 순서**'를 적고 '**TCP** or **UDP**'를 써서 만든 데이터의 형태를 **세그먼트**라고 한다.

### 세션 계층(Session Layer)

'네트워크 계층의 IP'를 통해 컴퓨터를 찾아가고, '전송 계층의 포트 번호'를 이용해 컴퓨터의 애플리케이션을 찾아가고, '전송 계층의 TCP or UDP'로 안전한/빠른 연결을 확인하였다.

그러고 나면 서버의 애플리케이션과 클라이언트의 애플리케이션 사이에 **데이터 전송을 위한 논리적인 연결통로**가 생긴다.

[ 이 때, 실시간으로 데이터를 주고 받기 위한 두 컴퓨터의 논리적 연결, 만남을 **세션(Session)**이라 하고, ]

[ 이런 세션을 만들고, 유지, 종료할 때 사용되는 기술과 장비들을 '**세션 계층**'이라고 한다. ]


### 표현 계층(Presentation Layer)

세션이 만들어지고, 데이터를 전송하려고 하는데, 각 애플리케이션마다 사용하는 데이터 형태가 다르다.

[ 그래서 세션을 통해 넘어오는 데이터들을 애플리케이션에서 필요한 형태로 변환(데이터를 어떻게 변환할지 다루는 계층)해 애플리케이션에서 표현하는 계층이기 때문에 '**표현 계층**'이라고 한다. ] 

데이터를 암호화하는 계층이고, 웹에서 흐르는 데이터를 암호화하려면 반드시 표현 계층을 거쳐야 한다.

### 응용 계층(Application Layer)

[ 우리가 사용하는 사용자 인터페이스를 제공하는 응용 프로그램들의 상호작용을 다루는 계층이다. ] 

세상에 정말 수없이 많은 응용프로그램이 있듯, 각 응용 프로그램에 사용하는 수많은 프로토콜이 있다.

대표적으로 인터넷상에서 문자(Hyper Text) 데이터를 다루는 프로토콜 **HTTP**, 파일을 주고 받을 때 사용하는 프로토콜 **FTP**, 도메인 네임서버를 찾을 때 사용하는 프로토콜 **DNS**, SSH 연결을 할 때 사용하는 프로토콜 **SSH** 등이 있다.


</details>

